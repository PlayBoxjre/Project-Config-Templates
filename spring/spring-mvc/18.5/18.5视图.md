# 18.5视图

### 18.5.1使用ViewResolver界面解析视图

如[第18.3节，“实施控制器”](http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-controller)中所讨论的，Spring Web MVC控制器中的所有处理器方法必须明确地（例如，通过返回`String`，`View`或`ModelAndView`）或隐式地（即基于惯例）。 Spring中的视图由逻辑视图名称来解决，并由视图解析器解决。 Spring有不少解析器。 这个表格列出了其中的大部分; 下面有几个例子。

**Table18.3.查看解析器**

| 视图解析器                            | 描述                                       |
| :------------------------------- | :--------------------------------------- |
| `AbstractCachingViewResolver`    | 抽象视图解析器缓存视图。通常情况下，需要准备才能使用; 扩展此视图解析器提供缓存。 |
| `XmlViewResolver`                | `ViewResolver`的实现，它接受一个用XML编写的配置文件，其中使用与Spring的XML bean工厂相同的DTD。 默认配置文件是`/WEB-INF/views.xml`。 |
| `ResourceBundleViewResolver`     | `ViewResolver`的实现，它使用由bundle基名指定的`ResourceBundle`中的bean定义。 通常，您可以在位于类路径中的属性文件中定义该包。 默认文件名是`views.properties`。 |
| `UrlBasedViewResolver`           | `ViewResolver`接口的简单实现，它实现了逻辑视图名称直接解析到URL，而没有明确的映射定义。 如果您的逻辑名称以直观的方式与您的视图资源的名称相匹配，而不需要任意映射，则这是适当的。 |
| `InternalResourceViewResolver`   | `UrlBasedViewResolver`的便捷子类支持`InternalResourceView`（实际上是Servlet和JSP）和子类（如`JstlView`和`TilesView`）。 您可以使用`setViewClass(..)`为由此解析器生成的所有视图指定视图类。 有关详细信息，请参阅`UrlBasedViewResolver` javadocs。 |
| `FreeMarkerViewResolver`         | `UrlBasedViewResolver`方便的子类，支持`FreeMarkerView`和它们的自定义子类。 |
| `ContentNegotiatingViewResolver` | 实现基于请求文件名或`Accept`头来解析视图的`ViewResolver`接口。 请参见[第18.5.4节“ContentNegotiatingViewResolver”](https://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-multiple-representations)。 |

例如，使用JSP作为视图技术，可以使用`UrlBasedViewResolver`。此视图解析器将视图名称转换为URL，并将请求转交给`RequestDispatcher`以呈现视图。

```java
<bean id="viewResolver"
        class="org.springframework.web.servlet.view.UrlBasedViewResolver">
    <property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/>
    <property name="prefix" value="/WEB-INF/jsp/"/>
    <property name="suffix" value=".jsp"/>
</bean>
```

当将`test`作为逻辑视图名称返回时，此视图解析器将请求转发给`RequestDispatcher`，`RequestDispatcher`将请求发送到`/WEB-INF/jsp/test.jsp`。

### 18.5.2链接视图解析器

Spring支持多个视图解析器。 因此，您可以链接解析器，并在某些情况下覆盖特定的视图。 您可以通过向应用程序上下文中添加多个解析器来链接视图解析器，并在必要时通过设置`order`属性来指定排序。

 **请记住，`order`属性越高，视图解析器在链中的位置越晚。**

如果一个特定的视图解析器没有产生视图，Spring会检查其他视图解析器的上下文。 如果存在额外的视图解析器，Spring将继续检查它们，直到视图解决。 如果没有视图解析器返回一个视图，Spring会抛出一个`ServletException`异常。

视图解析器的合约指定一个视图resolver\_can\_return为null以指示视图找不到。 然而并不是所有的视图解析器都这样做，因为在某些情况下，解析器根本无法检测视图是否存在。 例如，`InternalResourceViewResolver`在内部使用`RequestDispatcher`，调度是确定JSP是否存在的唯一方法，但此操作只能执行一次。 `FreeMarkerViewResolver`和其他的一样。 检查特定视图解析器的javadoc以查看是否报告不存在的视图。 因此，将一个`InternalResourceViewResolver`放在链中的最后一个结果链中没有被完全检查，因为`InternalResourceViewResolver `will\_always\_return一个视图！

### 18.5.3 重定向到视图

如前所述，控制器通常返回一个逻辑视图名称，视图解析器解析为一个特定的视图技术。 对于通过Servlet或JSP引擎处理的JSP等视图技术，此解决方案通常通过`InternalResourceViewResolver`和`InternalResourceView`的组合来处理，`InternalResourceView`和`InternalResourceView`通过Servlet API的`RequestDispatcher.forward(..)`方法或`RequestDispatcher.include()`方法。 对于其他视图技术，如FreeMarker，XSLT等，视图本身直接将内容写入响应流。

- 在呈现视图之前，有时需要发送HTTP重定向回客户端。例如，当使用`POST`数据调用一个控制器时，这是可取的，而响应实际上是对另一个控制器的委托（例如成功的表单提交）。

>  在这种情况下，正常的内部转发意味着另一个控制器也会看到相同的`POST`数据，如果可能会将其与其他预期数据混淆，则这可能会造成问题。

>  在显示结果之前执行重定向的另一个原因是消除了用户多次提交表单数据的可能性。在这种情况下，浏览器将首先发送一个初始`POST`;它会接收到重定向到不同的URL的响应;最后浏览器会对重定向响应中的URL进行后续的`GET`操作。因此，从浏览器的角度来看，当前页面并不反映`POST`的结果，而是`GET`的结果。最终的效果是用户无法通过`POST`执行刷新而意外地重新发布相同的数据。刷新强制结果页面的`GET`，而不是重新发送初始`POST`数据。

#### RedirectView

作为控制器响应的结果，强制重定向的一种方法是让控制器创建并返回Spring的`RedirectView`实例。 在这种情况下，`DispatcherServlet`不使用普通视图解析机制。 而是因为它已经被赋予了（重定向）视图，`DispatcherServlet`只是指示视图来完成它的工作。 `RedirectView`依次调用`HttpServletResponse.sendRedirect()`向客户端浏览器发送HTTP重定向。

如果使用RedirectView并且视图是由控制器本身创建的，则建议您将重定向URL配置为注入控制器，以使其不会被烘焙到控制器中，而是在上下文中与视图名称一起配置。 在[一节“重定向：前缀”](http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-redirecting-redirect-prefix)有利于这种脱钩。

#### 将数据传递到重定向目标

默认情况下，所有的模型属性都被认为是作为重定向URL中的URI模板变量公开的。 其余属性是原始类型或集合/基本类型数组，都自动附加为查询参数。

如果为重定向专门准备了模型实例，那么将基元类型属性附加为查询参数可能是期望的结果。 但是，在带注解的控制器中，模型可能包含为渲染目的而添加的附加属性（例如，下拉字段值）。 为了避免在URL中出现这样的属性，`@RequestMapping`方法可以声明`RedirectAttributes`类型的参数，并使用它来指定可用于`RedirectView`的确切属性。 如果方法确实重定向，则使用`RedirectAttributes`的内容。 否则使用模型的内容。

如果为重定向准备了模型实例，*则将原始类型属性作为查询参数附加可能是所需的结果。然而，在注解控制器中，模型可能包含为渲染目的添加的附加属性（例如下拉字段值）。*为了避免这种属性出现在URL中的可能性，一种`@RequestMapping`方法可以声明一个类型的参数，`RedirectAttributes`并使用它来指定可供使用的确切属性`RedirectView`。如果方法重定向，则使用内容`RedirectAttributes`。否则使用模型的内容。

`RequestMappingHandlerAdapter`提供了一个名为`“ignoreDefaultModelOnRedirect”`的标志，可用于指示默认`Model`的内容，如果控制器方法重定向，则永远不要使用该模型。 相反，控制器方法应声明`RedirectAttributes`类型的属性，或者如果不这样做，则不应将任何属性传递给`RedirectView`。 MVC命名空间和MVC Java配置都将此标志设置为`false`，以保持向后兼容性。 但是，对于新应用程序，我们建议将其设置为`true`

请注意，当前请求中的URI模板变量在扩展重定向URL时自动可用，不需要通过`Model`或`RedirectAttributes`显式添加。 例如：

```java
@PostMapping("/files/{path}")
public String upload(...) {
    // ...
    return "redirect:files/{path}";
}
```

将数据传递到重定向目标的另一种方法是通过_Flash属性_。与其他重定向属性不同，Flash属性保存在HTTP会话中（因此不会出现在URL中）。有关详细信息，请参见[第18.6节“使用Flash属性”](http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-flash-attributes)。

#### 重定向：前缀

特殊的`redirect:`前缀可以让你做到这一点。 如果返回具有前缀`redirect：`的视图名称，则`UrlBasedViewResolver`（和所有子类）将认识到这是需要重定向的特殊指示。 视图名称的其余部分将被视为重定向URL。

请注意，控制器处理程序使用注释`@ResponseStatus`，注释值优先于设置的响应状态`RedirectView`。

实际效果与控制器返回`RedirectView`的效果相同，但现在控制器本身可以简单地按照逻辑视图名称操作。 逻辑视图名称，例如`redirect:/myapp/some/resource`将相对于当前Servlet上下文重定向，而诸如`redirect:http://myhost.com/some/arbitrary/path`之类的名称将重定向到绝对URL。

请注意，控制器处理程序使用`@ResponseStatus`注解，注解值优先于`RedirectView`设置的响应状态。

#### 

#### 转发：前缀

对于最终由`UrlBasedViewResolver`和子类解析的视图名称，也可以使用特殊的`forward：`前缀。 这将创建一个内部`ResourceView`（最终执行一个`RequestDispatcher.forward()`），其余的视图名称被视为一个URL。 因此，这个前缀对于`InternalResourceViewResolver`和`InternalResourceView`（例如JSP）是没有用的。 但是，当您主要使用其他视图技术时，前缀可能会很有帮助，但仍希望强制转发资源，以便由Servlet/JSP引擎处理。 （请注意，您也可以链接多个视图解析器）。

与`redirect:`前缀一样，如果带有`forward：`前缀的视图名称被注入到控制器中，则控制器不会检测到处理响应方面的任何特殊情况。

### 18.5.4ContentNegotiatingViewResolver

`ContentNegotiatingViewResolver`不会自己解析视图，而是委托给其他视图解析器，选择类似于客户端请求的视图。 有两种策略可以让客户从服务器请求表示：

- 对每个资源使用不同的URI，通常在URI中使用不同的文件扩展名。 例如，URI `http://www.example.com/users/fred.pdf`请求用户fred的PDF表示，而`http://www.example.com/users/fred.xml`请求XML表示。
- 为客户端使用相同的URI来定位资源，但是设置`Accept` HTTP请求头来列出它理解的[媒体类型](https://en.wikipedia.org/wiki/Internet_media_type)。 例如，`http://www.example.com/users/fred`的一个HTTP请求的`Accept`标头设置为`application/pdf`，请求用户fred的PDF表示，同时[`http://www.example.com/users/fred`](http://www.example.com/users/fred)使用`Accept`头设置来`text/xml`请求XML表示。 这个策略被称为[内容谈判](https://en.wikipedia.org/wiki/Content_negotiation)。

| ![](https://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/images/note.png) |
| :--------------------------------------- |
| `Accept`头的一个问题是，不可能在HTML中的Web浏览器中设置它。 例如，在Firefox中，它被固定为：`Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`因此，通常会看到使用 开发基于浏览器的Web应用程序时，每个表示的URI都是不同的。 |

为了支持资源的多重表示，Spring提供了`ContentNegotiatingViewResolver`来根据HTTP请求的文件扩展名或者`Accept`头来解析一个视图。`ContentNegotiatingViewResolver`本身并不执行视图解析，而是委托给你指定的视图解析器列表 bean属性`ViewResolvers`。

#### 1.16.6。内容谈判

您可以配置Spring MVC如何根据请求确定请求的媒体类型。

- 可用的选项是检查查询参数，
- 文件扩展名的URL路径，
- “Accept”标头，使用固定列表还是自定义策略。

默认情况下，为了向后兼容，首先检查请求URI中的路径扩展，然后检查“Accept”头。但是，如果您必须使用基于URL的内容类型解析，则强烈建议在路径扩展上使用查询参数策略，因为后者可能会导致URI变量，路径参数以及URI解码相结合的问题。

在MVC的Java配置和MVC命名寄存器`json`，`xml`，`rss`，`atom`在默认情况下，如果相应的依赖都在类路径中。额外的路径扩展到媒体类型的映射也可以被明确注册，并且为了RFD攻击检测的目的（参见[后缀模式匹配和RFD](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/web.html#mvc-ann-requestmapping-rfd)的更多细节），也具有将它们白名单作为安全扩展的效果。

以下是通过MVC Java配置自定义内容协商选项的示例：

以下是通过MVC Java配置自定义内容协商选项的示例：

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

        @Override
        public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
                configurer.mediaType("json", MediaType.APPLICATION_JSON);
        }
}
```

在MVC命名空间中，`<mvc:annotation-driven>`元素有一个 `content-negotiation-manager`属性，这个属性`ContentNegotiationManager` 可以创建一个`ContentNegotiationManagerFactoryBean`：

```xml
<!-- 必须是 id = ‘contentNegotiationManager’-->
<mvc:annotation-driven content-negotiation-manager="contentNegotiationManager"/>

<bean id="contentNegotiationManager" class="org.springframework.web.accept.ContentNegotiationManagerFactoryBean">
        <property name="mediaTypes">
                <value>
                        json=application/json
                        xml=application/xml
                </value>
        </property>
</bean>

--------2---
    <bean id="contentNegotiatingViewResolver"
        class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver">
        <property name="contentNegotiationManager">
            <bean autowire-candidate="true"
                  class="org.springframework.web.accept.ContentNegotiationManagerFactoryBean" init-method="build">
                <property name="mediaTypes">
                    <map>

                    </map>
                </property>
                <property name="defaultContentType" value="text/html"/>
                <property name="favorParameter" value="true"/>
                <property name="favorPathExtension" value="true"/>
                <property name="ignoreAcceptHeader" value="false"/>
                <property name="parameterName" value="type"/>
                <property name="useRegisteredExtensionsOnly" value="false"/>
            </bean>
        </property>
</bean>
```