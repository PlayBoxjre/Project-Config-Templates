# Web Mvc 框架 1

https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/web.html#mvc-exceptionhandlers

### 18.5.1使用ViewResolver界面解析视图

如[第18.3节，“实施控制器”](http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-controller)中所讨论的，Spring Web MVC控制器中的所有处理器方法必须明确地（例如，通过返回`String`，`View`或`ModelAndView`）或隐式地（即基于惯例）。 Spring中的视图由逻辑视图名称来解决，并由视图解析器解决。 Spring有不少解析器。 这个表格列出了其中的大部分; 下面有几个例子。

**Table18.3.查看解析器**

| 视图解析器                            | 描述                                       |
| :------------------------------- | :--------------------------------------- |
| `AbstractCachingViewResolver`    | 抽象视图解析器缓存视图。通常情况下，需要准备才能使用; 扩展此视图解析器提供缓存。 |
| `XmlViewResolver`                | `ViewResolver`的实现，它接受一个用XML编写的配置文件，其中使用与Spring的XML bean工厂相同的DTD。 默认配置文件是`/WEB-INF/views.xml`。 |
| `ResourceBundleViewResolver`     | `ViewResolver`的实现，它使用由bundle基名指定的`ResourceBundle`中的bean定义。 通常，您可以在位于类路径中的属性文件中定义该包。 默认文件名是`views.properties`。 |
| `UrlBasedViewResolver`           | `ViewResolver`接口的简单实现，它实现了逻辑视图名称直接解析到URL，而没有明确的映射定义。 如果您的逻辑名称以直观的方式与您的视图资源的名称相匹配，而不需要任意映射，则这是适当的。 |
| `InternalResourceViewResolver`   | `UrlBasedViewResolver`的便捷子类支持`InternalResourceView`（实际上是Servlet和JSP）和子类（如`JstlView`和`TilesView`）。 您可以使用`setViewClass(..)`为由此解析器生成的所有视图指定视图类。 有关详细信息，请参阅`UrlBasedViewResolver` javadocs。 |
| `FreeMarkerViewResolver`         | `UrlBasedViewResolver`方便的子类，支持`FreeMarkerView`和它们的自定义子类。 |
| `ContentNegotiatingViewResolver` | 实现基于请求文件名或`Accept`头来解析视图的`ViewResolver`接口。 请参见[第18.5.4节“ContentNegotiatingViewResolver”](https://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-multiple-representations)。 |

例如，使用JSP作为视图技术，可以使用`UrlBasedViewResolver`。此视图解析器将视图名称转换为URL，并将请求转交给`RequestDispatcher`以呈现视图。

```java
<bean id="viewResolver"
        class="org.springframework.web.servlet.view.UrlBasedViewResolver">
    <property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/>
    <property name="prefix" value="/WEB-INF/jsp/"/>
    <property name="suffix" value=".jsp"/>
</bean>
```

当将`test`作为逻辑视图名称返回时，此视图解析器将请求转发给`RequestDispatcher`，`RequestDispatcher`将请求发送到`/WEB-INF/jsp/test.jsp`。

### 18.5.2链接视图解析器

Spring支持多个视图解析器。 因此，您可以链接解析器，并在某些情况下覆盖特定的视图。 您可以通过向应用程序上下文中添加多个解析器来链接视图解析器，并在必要时通过设置`order`属性来指定排序。

 **请记住，`order`属性越高，视图解析器在链中的位置越晚。**

如果一个特定的视图解析器没有产生视图，Spring会检查其他视图解析器的上下文。 如果存在额外的视图解析器，Spring将继续检查它们，直到视图解决。 如果没有视图解析器返回一个视图，Spring会抛出一个`ServletException`异常。

视图解析器的合约指定一个视图resolver\_can\_return为null以指示视图找不到。 然而并不是所有的视图解析器都这样做，因为在某些情况下，解析器根本无法检测视图是否存在。 例如，`InternalResourceViewResolver`在内部使用`RequestDispatcher`，调度是确定JSP是否存在的唯一方法，但此操作只能执行一次。 `FreeMarkerViewResolver`和其他的一样。 检查特定视图解析器的javadoc以查看是否报告不存在的视图。 因此，将一个`InternalResourceViewResolver`放在链中的最后一个结果链中没有被完全检查，因为`InternalResourceViewResolver `will\_always\_return一个视图！

### 18.5.3 重定向到视图

如前所述，控制器通常返回一个逻辑视图名称，视图解析器解析为一个特定的视图技术。 对于通过Servlet或JSP引擎处理的JSP等视图技术，此解决方案通常通过`InternalResourceViewResolver`和`InternalResourceView`的组合来处理，`InternalResourceView`和`InternalResourceView`通过Servlet API的`RequestDispatcher.forward(..)`方法或`RequestDispatcher.include()`方法。 对于其他视图技术，如FreeMarker，XSLT等，视图本身直接将内容写入响应流。

- 在呈现视图之前，有时需要发送HTTP重定向回客户端。例如，当使用`POST`数据调用一个控制器时，这是可取的，而响应实际上是对另一个控制器的委托（例如成功的表单提交）。

>  在这种情况下，正常的内部转发意味着另一个控制器也会看到相同的`POST`数据，如果可能会将其与其他预期数据混淆，则这可能会造成问题。

>  在显示结果之前执行重定向的另一个原因是消除了用户多次提交表单数据的可能性。在这种情况下，浏览器将首先发送一个初始`POST`;它会接收到重定向到不同的URL的响应;最后浏览器会对重定向响应中的URL进行后续的`GET`操作。因此，从浏览器的角度来看，当前页面并不反映`POST`的结果，而是`GET`的结果。最终的效果是用户无法通过`POST`执行刷新而意外地重新发布相同的数据。刷新强制结果页面的`GET`，而不是重新发送初始`POST`数据。

#### RedirectView

作为控制器响应的结果，强制重定向的一种方法是让控制器创建并返回Spring的`RedirectView`实例。 在这种情况下，`DispatcherServlet`不使用普通视图解析机制。 而是因为它已经被赋予了（重定向）视图，`DispatcherServlet`只是指示视图来完成它的工作。 `RedirectView`依次调用`HttpServletResponse.sendRedirect()`向客户端浏览器发送HTTP重定向。

如果使用RedirectView并且视图是由控制器本身创建的，则建议您将重定向URL配置为注入控制器，以使其不会被烘焙到控制器中，而是在上下文中与视图名称一起配置。 在[一节“重定向：前缀”](http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-redirecting-redirect-prefix)有利于这种脱钩。

#### 将数据传递到重定向目标

默认情况下，所有的模型属性都被认为是作为重定向URL中的URI模板变量公开的。 其余属性是原始类型或集合/基本类型数组，都自动附加为查询参数。

如果为重定向专门准备了模型实例，那么将基元类型属性附加为查询参数可能是期望的结果。 但是，在带注解的控制器中，模型可能包含为渲染目的而添加的附加属性（例如，下拉字段值）。 为了避免在URL中出现这样的属性，`@RequestMapping`方法可以声明`RedirectAttributes`类型的参数，并使用它来指定可用于`RedirectView`的确切属性。 如果方法确实重定向，则使用`RedirectAttributes`的内容。 否则使用模型的内容。

如果为重定向准备了模型实例，*则将原始类型属性作为查询参数附加可能是所需的结果。然而，在注解控制器中，模型可能包含为渲染目的添加的附加属性（例如下拉字段值）。*为了避免这种属性出现在URL中的可能性，一种`@RequestMapping`方法可以声明一个类型的参数，`RedirectAttributes`并使用它来指定可供使用的确切属性`RedirectView`。如果方法重定向，则使用内容`RedirectAttributes`。否则使用模型的内容。

`RequestMappingHandlerAdapter`提供了一个名为`“ignoreDefaultModelOnRedirect”`的标志，可用于指示默认`Model`的内容，如果控制器方法重定向，则永远不要使用该模型。 相反，控制器方法应声明`RedirectAttributes`类型的属性，或者如果不这样做，则不应将任何属性传递给`RedirectView`。 MVC命名空间和MVC Java配置都将此标志设置为`false`，以保持向后兼容性。 但是，对于新应用程序，我们建议将其设置为`true`

请注意，当前请求中的URI模板变量在扩展重定向URL时自动可用，不需要通过`Model`或`RedirectAttributes`显式添加。 例如：

```java
@PostMapping("/files/{path}")
public String upload(...) {
    // ...
    return "redirect:files/{path}";
}
```

将数据传递到重定向目标的另一种方法是通过_Flash属性_。与其他重定向属性不同，Flash属性保存在HTTP会话中（因此不会出现在URL中）。有关详细信息，请参见[第18.6节“使用Flash属性”](http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-flash-attributes)。

#### 重定向：前缀

特殊的`redirect:`前缀可以让你做到这一点。 如果返回具有前缀`redirect：`的视图名称，则`UrlBasedViewResolver`（和所有子类）将认识到这是需要重定向的特殊指示。 视图名称的其余部分将被视为重定向URL。

请注意，控制器处理程序使用注释`@ResponseStatus`，注释值优先于设置的响应状态`RedirectView`。

实际效果与控制器返回`RedirectView`的效果相同，但现在控制器本身可以简单地按照逻辑视图名称操作。 逻辑视图名称，例如`redirect:/myapp/some/resource`将相对于当前Servlet上下文重定向，而诸如`redirect:http://myhost.com/some/arbitrary/path`之类的名称将重定向到绝对URL。

请注意，控制器处理程序使用`@ResponseStatus`注解，注解值优先于`RedirectView`设置的响应状态。

#### 

#### 转发：前缀

对于最终由`UrlBasedViewResolver`和子类解析的视图名称，也可以使用特殊的`forward：`前缀。 这将创建一个内部`ResourceView`（最终执行一个`RequestDispatcher.forward()`），其余的视图名称被视为一个URL。 因此，这个前缀对于`InternalResourceViewResolver`和`InternalResourceView`（例如JSP）是没有用的。 但是，当您主要使用其他视图技术时，前缀可能会很有帮助，但仍希望强制转发资源，以便由Servlet/JSP引擎处理。 （请注意，您也可以链接多个视图解析器）。

与`redirect:`前缀一样，如果带有`forward：`前缀的视图名称被注入到控制器中，则控制器不会检测到处理响应方面的任何特殊情况。

### 18.5.4ContentNegotiatingViewResolver

`ContentNegotiatingViewResolver`不会自己解析视图，而是委托给其他视图解析器，选择类似于客户端请求的视图。 有两种策略可以让客户从服务器请求表示：

- 对每个资源使用不同的URI，通常在URI中使用不同的文件扩展名。 例如，URI `http://www.example.com/users/fred.pdf`请求用户fred的PDF表示，而`http://www.example.com/users/fred.xml`请求XML表示。
- 为客户端使用相同的URI来定位资源，但是设置`Accept` HTTP请求头来列出它理解的[媒体类型](https://en.wikipedia.org/wiki/Internet_media_type)。 例如，`http://www.example.com/users/fred`的一个HTTP请求的`Accept`标头设置为`application/pdf`，请求用户fred的PDF表示，同时[`http://www.example.com/users/fred`](http://www.example.com/users/fred)使用`Accept`头设置来`text/xml`请求XML表示。 这个策略被称为[内容谈判](https://en.wikipedia.org/wiki/Content_negotiation)。

| ![](https://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/images/note.png) |
| :--------------------------------------- |
| `Accept`头的一个问题是，不可能在HTML中的Web浏览器中设置它。 例如，在Firefox中，它被固定为：`Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`因此，通常会看到使用 开发基于浏览器的Web应用程序时，每个表示的URI都是不同的。 |

为了支持资源的多重表示，Spring提供了`ContentNegotiatingViewResolver`来根据HTTP请求的文件扩展名或者`Accept`头来解析一个视图。`ContentNegotiatingViewResolver`本身并不执行视图解析，而是委托给你指定的视图解析器列表 bean属性`ViewResolvers`。

#### 1.16.6。内容谈判

您可以配置Spring MVC如何根据请求确定请求的媒体类型。

- 可用的选项是检查查询参数，
- 文件扩展名的URL路径，
- “Accept”标头，使用固定列表还是自定义策略。

默认情况下，为了向后兼容，首先检查请求URI中的路径扩展，然后检查“Accept”头。但是，如果您必须使用基于URL的内容类型解析，则强烈建议在路径扩展上使用查询参数策略，因为后者可能会导致URI变量，路径参数以及URI解码相结合的问题。

在MVC的Java配置和MVC命名寄存器`json`，`xml`，`rss`，`atom`在默认情况下，如果相应的依赖都在类路径中。额外的路径扩展到媒体类型的映射也可以被明确注册，并且为了RFD攻击检测的目的（参见[后缀模式匹配和RFD](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/web.html#mvc-ann-requestmapping-rfd)的更多细节），也具有将它们白名单作为安全扩展的效果。

以下是通过MVC Java配置自定义内容协商选项的示例：

以下是通过MVC Java配置自定义内容协商选项的示例：

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

        @Override
        public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
                configurer.mediaType("json", MediaType.APPLICATION_JSON);
        }
}
```

在MVC命名空间中，`<mvc:annotation-driven>`元素有一个 `content-negotiation-manager`属性，这个属性`ContentNegotiationManager` 可以创建一个`ContentNegotiationManagerFactoryBean`：

```xml
<!-- 必须是 id = ‘contentNegotiationManager’-->
<mvc:annotation-driven content-negotiation-manager="contentNegotiationManager"/>

<bean id="contentNegotiationManager" class="org.springframework.web.accept.ContentNegotiationManagerFactoryBean">
        <property name="mediaTypes">
                <value>
                        json=application/json
                        xml=application/xml
                </value>
        </property>
</bean>

--------2---
    <bean id="contentNegotiatingViewResolver"
        class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver">
        <property name="contentNegotiationManager">
            <bean autowire-candidate="true"
                  class="org.springframework.web.accept.ContentNegotiationManagerFactoryBean" init-method="build">
                <property name="mediaTypes">
                    <map>

                    </map>
                </property>
                <property name="defaultContentType" value="text/html"/>
                <property name="favorParameter" value="true"/>
                <property name="favorPathExtension" value="true"/>
                <property name="ignoreAcceptHeader" value="false"/>
                <property name="parameterName" value="type"/>
                <property name="useRegisteredExtensionsOnly" value="false"/>
            </bean>
        </property>
</bean>
```

### 1.6。使用Flash属性

Flash属性提供了一种请求来存储供另一个使用的属性的方法。这是重定向时最常需要的 - 例如 *Post / Redirect / Get*模式。在重定向（通常在会话中）之前，Flash属性会临时保存，以便在重定向之后立即将其删除。

Spring MVC有两个主要的抽象来支持Flash属性。`FlashMap`用于保存闪存属性，同时`FlashMapManager`用于存储，检索和管理`FlashMap`实例。

Flash属性支持始终处于“打开”状态，不需要显式启用即使未使用也不会导致创建HTTP会话。每个请求都有一个“输入”，`FlashMap`其中包含从前一个请求（如果有）传递的属性和一个`FlashMap`带有属性的“输出” ，以保存后续请求。这两个`FlashMap`实例都可以从Spring MVC中的任何地方通过静态方法访问 `RequestContextUtils`。

带注释的控制器通常不需要`FlashMap`直接使用。相反，一个 `@RequestMapping`方法可以接受一个类型的参数，`RedirectAttributes`并用它为重定向场景添加flash属性。通过添加的Flash属性 `RedirectAttributes`自动传播到“输出”FlashMap。同样，重定向之后，来自“输入”的属性`FlashMap`会自动添加到 `Model`为目标URL提供服务的控制器中。

>  # 将请求匹配到Flash属性

> Flash属性的概念存在于许多其他Web框架中，并且已经被证明有时会暴露给并发问题。这是因为根据定义，闪存属性将被存储直到下一个请求。然而，非常“下一个”请求可能不是预期的接收者，而是另一个异步请求（例如，轮询或资源请求），在这种情况下，Flash属性被过早地移除。

> 为了减少此类问题发生的可能性，请使用目标重定向URL的路径和查询参数`RedirectView`自动“戳记” `FlashMap`实例。在`FlashMapManager`查找“输入”时，默认情况下，该信息与传入请求相匹配`FlashMap`。

> 这并不能完全消除并发问题的可能性，但是尽管如此，通过重定向URL中已有的信息大大减少了这种可能性。因此，建议主要针对重定向场景使用Flash属性。

### 1.7。建立URI

Spring MVC提供了使用`UriComponentsBuilder`和构建和编码URI的机制 `UriComponents`。

例如，您可以展开和编码一个URI模板字符串：

```java
UriComponents uriComponents = UriComponentsBuilder.fromUriString(
                "http://example.com/hotels/{hotel}/bookings/{booking}").build();

URI uri = uriComponents.expand("42", "21").encode().toUri();
```

请注意，这`UriComponents`是不可变的`expand()`，`encode()`如果需要的话，和操作会返回新的实例。

您还可以使用单独的URI组件进行展开和编码：

```java
UriComponents uriComponents = UriComponentsBuilder.newInstance()
                .scheme("http").host("example.com").path("/hotels/{hotel}/bookings/{booking}").build()
                .expand("42", "21")
                .encode();
```

在Servlet环境中，`ServletUriComponentsBuilder`子类提供静态工厂方法来从Servlet请求中复制可用的URL信息：

```java
HttpServletRequest request = ...

// Re-use host, scheme, port, path and query string
// Replace the "accountId" query param

ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromRequest(request)
                .replaceQueryParam("accountId", "{id}").build()
                .expand("123")
                .encode();
```

或者，您可以选择将可用信息的一个子集复制到上下文路径（包括上下文路径）：

```
// Re-use host, port and context path
// Append "/accounts" to the path

ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromContextPath(request)
                .path("/accounts").build()
```

或者，在`DispatcherServlet`名称（例如`/main/*`）映射的情况下，还可以包含servlet映射的文字部分：

```java
// Re-use host, port, context path
// Append the literal part of the servlet mapping to the path
// Append "/accounts" to the path

ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromServletMapping(request)
                .path("/accounts").build()
```

#### 1.7.1。为控制器和方法构建URI

Spring MVC还提供了一种构建控制器方法链接的机制。例如，给出：

```
@Controller
@RequestMapping("/hotels/{hotel}")
public class BookingController {

        @GetMapping("/bookings/{booking}")
        public String getBooking(@PathVariable Long booking) {

        // ...
       }
}
```

您可以通过名称引用方法来准备链接：

```
UriComponents uriComponents = MvcUriComponentsBuilder
        .fromMethodName(BookingController.class, "getBooking", 21).buildAndExpand(42);

URI uri = uriComponents.encode().toUri();
```

在上面的例子中，我们提供了实际的方法参数值，在这种情况下是long值21，被用作路径变量并被插入到URL中。此外，我们提供了值42以填充任何剩余的URI变量，例如从类型级别请求映射继承的“酒店”变量。如果方法有更多的参数，你可以为URL提供不需要的参数。一般只有`@PathVariable`和`@RequestParam`参数是有关构造URL。

还有其他方法可以使用`MvcUriComponentsBuilder`

```
UriComponents uriComponents = MvcUriComponentsBuilder
        .fromMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);

URI uri = uriComponents.encode().toUri();
```

上面的例子使用了静态方法`MvcUriComponentsBuilder`。他们在内部依靠`ServletUriComponentsBuilder`从当前请求的方案，主机，端口，上下文路径和servlet路径准备基本URL。这在大多数情况下运作良好，但有时可能不足。例如，您可能在请求的上下文之外（例如，准备链接的批处理过程），或者您可能需要插入路径前缀（例如，从请求路径中删除并需要重新插入链接的区域设置前缀）。

对于这种情况，您可以使用静态“fromXxx”重载方法来接受 `UriComponentsBuilder`使用基本URL。或者您可以`MvcUriComponentsBuilder` 使用基本URL 创建实例，然后使用基于实例的“withXxx”方法。例如：

```
UriComponentsBuilder base = ServletUriComponentsBuilder.fromCurrentContextPath().path("/en");
MvcUriComponentsBuilder builder = MvcUriComponentsBuilder.relativeTo(base);
builder.withMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);

URI uri = uriComponents.encode().toUri();
```

#### 1.7.2。使用“转发”和“X-Forwarded- *”标题

当请求经过负载平衡器等代理时，主机，端口和方案可能会改变，这对于需要创建资源链接的应用程序提出了挑战，因为链接应反映原始请求的主机，端口和方案客户端的角度。

[RFC 7239](https://tools.ietf.org/html/rfc7239)定义了代理的“转发”HTTP头，用于提供有关原始请求的信息。还有其他非标准的标题，例如“X-Forwarded-Host”，“X-Forwarded-Port”和“X-Forwarded-Proto”。

既`ServletUriComponentsBuilder`和`MvcUriComponentsBuilder`检测，提取，并从“转发”头，或从“X -转发，主机”使用信息，“X-转发端口”和“X-转发，原”如果“转发”不存在，以便生成的链接反映原始请求。

在`ForwardedHeaderFilter`提供了一个替代方案为整个应用程序做同样的曾经和全球。过滤器包装请求以覆盖主机，端口和方案信息，并“隐藏”任何转发的头部以供后续处理。

请注意，如RFC 7239的第8部分中所述，使用转发标头时存在安全考虑事项。在应用程序级别，很难确定转发标头是否可信。这就是为什么网络上游应该被正确配置，以从外部过滤出不可信的转发标题。

没有代理并且不需要使用转发标头的应用程序可以配置`ForwardedHeaderFilter`为删除并忽略这些标头。

#### 1.7.3。从视图构建控制器和方法的URI

您还可以从视图（如JSP，Thymeleaf，FreeMarker）建立到注释控制器的链接。这可以使用 其中引用按名称映射的`fromMappingName`方法来完成`MvcUriComponentsBuilder`。

每一个都`@RequestMapping`被分配一个基于类的大写字母和完整的方法名称的默认名称。例如，`getFoo`类中的方法`FooController` 被分配名称“FC＃getFoo”。这个策略可以通过创建一个实例`HandlerMethodMappingNamingStrategy`并将其插入你 的实例来替换或定制`RequestMappingHandlerMapping`。默认策略实现也会查看name属性`@RequestMapping`并使用它，如果存在的话。这意味着如果分配的默认映射名称与另一个名称冲突（例如重载的方法），您可以明确指定一个名称`@RequestMapping`。

| **   | 分配的请求映射名称在启动时记录在TRACE级别。 |
| ---- | ------------------------ |
|      |                          |

Spring JSP标记库提供了一个叫做的函数`mvcUrl`，可以用来根据这个机制来准备控制器方法的链接。

例如给出：

```
@RequestMapping("/people/{id}/addresses")
public class PersonAddressController {

    @RequestMapping("/{country}")
    public HttpEntity getAddress(@PathVariable String country) { ... }
}
```

您可以按如下方式从JSP准备链接：

```
<%@ taglib uri="http://www.springframework.org/tags" prefix="s" %>
...
<a href="${s:mvcUrl('PAC#getAddress').arg(0,'US').buildAndExpand('123')}">Get Address</a>
```

上面的例子依赖于`mvcUrl`Spring标记库中声明的JSP函数（即META-INF / spring.tld）。对于更高级的情况（例如上一节中介绍的自定义基本URL），可以轻松定义自己的函数或使用自定义标记文件，以便使用`MvcUriComponentsBuilder`具有自定义基本URL 的特定实例。

### 1.8。使用语言环境

Spring的架构大部分支持国际化，就像Spring的web MVC框架一样。`DispatcherServlet`使您能够使用客户端的区域设置自动解析消息。这是用`LocaleResolver`对象完成的。

当请求进入时，`DispatcherServlet`查找一个语言环境解析器，如果它找到一个它尝试使用它来设置语言环境。使用该`RequestContext.getLocale()` 方法，您始终可以检索由区域设置解析程序解析的区域设置。

除了自动区域设置解析之外，您还可以在处理程序映射中附加拦截器（请参阅[使用HandlerInterceptor拦截请求以](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/web.html#mvc-handlermapping-interceptor)获取有关处理程序映射拦截器的更多信息），以便在特定情况下更改区域设置，例如，基于请求中的参数。

区域设置解析器和拦截器在`org.springframework.web.servlet.i18n`包中定义， 并以正常方式在应用程序上下文中配置。这里是Spring中包含的一个语言环境解析器的选择。

#### 1.8.1。获取时区信息

#### 1.8.1。获取时区信息

除了获取客户端的语言环境外，知道他们的时区通常也很有用。该`LocaleContextResolver`接口提供了一个扩展`LocaleResolver`，允许解析器提供更丰富`LocaleContext`，其中可能包括时区信息。

可用时，`TimeZone`可以使用该`RequestContext.getTimeZone()`方法获取 用户。时区信息将自动由日期/时间`Converter`和`Formatter`Spring's注册的对象使用 `ConversionService`。

#### 1.8.2。AcceptHeaderLocaleResolver

此语言环境解析程序检查`accept-language`客户端发送的请求中的标头（例如Web浏览器）。通常这个头字段包含客户端操作系统的区域设置。*请注意，此解析器不支持时区信息。*

#### 1.8.3。CookieLocaleResolver的

此语言环境解析程序将检查`Cookie`客户端上可能存在的是否指定了 `Locale`or `TimeZone`。如果是这样，它使用指定的细节。使用此语言环境解析器的属性，您可以指定cookie的名称以及最大年龄。在下面找到一个定义a的例子`CookieLocaleResolver`。

```
<bean id="localeResolver" class="org.springframework.web.servlet.i18n.CookieLocaleResolver">

        <property name="cookieName" value="clientlanguage"/>

        <!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) -->
        <property name="cookieMaxAge" value="100000"/>

</bean>
```

| 属性            | 默认                 | 描述                                       |
| ------------- | ------------------ | ---------------------------------------- |
| cookieName    | classname + LOCALE | Cookie的名称                                |
| 名cookieMaxAge | Servlet容器默认        | cookie保持在客户端上的最长时间。如果指定了-1，那么cookie将不会被保留; 它只有在客户端关闭浏览器之后才可用。 |
| cookiePath    | /                  | 限制Cookie的可见性到您网站的某个部分。当指定cookiePath时，cookie将只对该路径及其下面的路径可见。 |

#### 1.8.4。SessionLocaleResolver

在`SessionLocaleResolver`可以检索`Locale`并`TimeZone`从可能与用户的请求相关的会话。相比之下 `CookieLocaleResolver`，这种策略将本地选择的区域设置存储在Servlet容器中`HttpSession`。因此，这些设置对于每个会话都是临时的，因此在每个会话终止时都会丢失。

请注意，与Spring Session项目等外部会话管理机制没有直接关系。这`SessionLocaleResolver`将简单地评估和修改`HttpSession`针对当前的相应属性`HttpServletRequest`。

#### 1.8.5。LocaleChangeInterceptor

您可以通过添加`LocaleChangeInterceptor`一个处理程序映射来启用区域设置的更改（请参阅[处理](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/web.html#mvc-handlermapping)程序[映射](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/web.html#mvc-handlermapping)）。它会检测请求中的参数并更改语言环境。它调用`setLocale()`的`LocaleResolver`是也存在于上下文。以下示例显示调用`*.view`包含名为参数的所有资源`siteLanguage`现在将更改语言环境。因此，例如，对以下网址的请求`http://www.sf.net/home.view?siteLanguage=nl`会将网站语言更改为荷兰语。

```
<bean id="localeChangeInterceptor"
                class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor">
        <property name="paramName" value="siteLanguage"/>
</bean>

<bean id="localeResolver"
                class="org.springframework.web.servlet.i18n.CookieLocaleResolver"/>

<bean id="urlMapping"
                class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
        <property name="interceptors">
                <list>
                        <ref bean="localeChangeInterceptor"/>
                </list>
        </property>
        <property name="mappings">
                <value>/**/*.view=someController</value>
        </property>
</bean>
```

### 1.9。使用主题

#### 1.9.1。主题概述

您可以应用Spring Web MVC框架主题来设置应用程序的整体外观，从而提高用户体验。主题是静态资源的集合，通常是样式表和图像，它们会影响应用程序的视觉风格。

#### 1.9.2。定义主题

要在您的Web应用程序中使用主题，您必须设置`org.springframework.ui.context.ThemeSource`接口的实现 。该`WebApplicationContext` 接口扩展`ThemeSource`，但其代表职责的专用实现。默认情况下，委托将是一个`org.springframework.ui.context.support.ResourceBundleThemeSource`从类路径的根目录加载属性文件的 实现。要使用自定义`ThemeSource` 实现或配置基本名称前缀`ResourceBundleThemeSource`，可以使用保留名称在应用程序上下文中注册一个bean `themeSource`。Web应用程序上下文自动检测具有该名称的bean并使用它。

使用时`ResourceBundleThemeSource`，主题是在一个简单的属性文件中定义的。属性文件列出组成主题的资源。这里是一个例子：

```
styleSheet = / themes / cool / style.css 
background = / themes / cool / img / coolBg.jpg
```

属性的键是从视图代码引用主题元素的名称。对于JSP，通常使用与`spring:theme`标签非常相似的自定义标签来执行此操作`spring:message`。以下JSP片段使用前面示例中定义的主题来自定义外观：

```
<%@ taglib prefix="spring" uri="http://www.springframework.org/tags"%>
<html>
        <head>
                <link rel="stylesheet" href="<spring:theme code='styleSheet'/>" type="text/css"/>
        </head>
        <body style="background=<spring:theme code='background'/>">
                ...
        </body>
</html>
```

默认情况下，`ResourceBundleThemeSource`使用空的基本名称前缀。因此，属性文件是从类路径的根目录加载的。因此，您可以将 `cool.properties`主题定义放在类路径根目录中，例如in `/WEB-INF/classes`。在`ResourceBundleThemeSource`使用标准的Java资源包加载机制，允许主题的国际化。例如，我们可以使用一个`/WEB-INF/classes/cool_nl.properties`带有荷兰文字的特殊背景图片。

#### 1.9.3。主题解析器

在定义主题之后，如上一节所述，决定使用哪个主题。该 `DispatcherServlet`会寻找一个叫豆`themeResolver`，以找出`ThemeResolver`使用实施。一个主题解析器的工作方式与a相同 `LocaleResolver`。它检测用于特定请求的主题，也可以更改请求的主题。Spring提供以下主题解析器：

| 类                      | 描述                                       |
| ---------------------- | ---------------------------------------- |
| `FixedThemeResolver`   | 选择使用`defaultThemeName`属性设置的固定主题。         |
| `SessionThemeResolver` | 主题在用户的HTTP会话中维护。它只需要为每个会话设置一次，但不会在会话之间持续。 |
| `CookieThemeResolver`  | 所选主题存储在客户端的Cookie中。                      |

Spring还提供了一个`ThemeChangeInterceptor`允许使用简单的请求参数在每个请求上进行主题更改的方法。

### 1.10。Spring的多部分（文件上传）支持

#### 1.10.1。介绍

Spring的内置多部分支持可以在Web应用程序中处理文件上传。您可以使用包中`MultipartResolver`定义的可插入对象来 启用此多部分支持`org.springframework.web.multipart`。Spring提供了一个`MultipartResolver` 用于[*Commons FileUpload的实现*](https://jakarta.apache.org/commons/fileupload)，另一个用于Servlet 3.0多部分请求解析。

默认情况下，Spring没有多部分处理，因为有些开发人员想要自己处理多部分。通过将多部分解析器添加到Web应用程序的上下文中来启用Spring多部分处理。检查每个请求，看它是否包含多部分。如果找不到多部分，请求将按预期继续。如果在请求中找到多部分，`MultipartResolver`则使用在您的上下文中声明的部分。之后，请求中的多部分属性就像任何其他属性一样处理。

#### 1.10.2。与*Commons FileUpload*一起使用MultipartResolver**

以下示例显示如何使用`CommonsMultipartResolver`：

```
<bean id="multipartResolver"
                class="org.springframework.web.multipart.commons.CommonsMultipartResolver">

        <!-- one of the properties available; the maximum file size in bytes -->
        <property name="maxUploadSize" value="100000"/>

</bean>
```

当然，你也需要在你的类路径中放入适当的jar，以便多部分解析器工作。在这种情况下`CommonsMultipartResolver`，你需要使用`commons-fileupload.jar`。

当Spring `DispatcherServlet`检测到多部分请求时，它会激活已经在上下文中声明的解析器并移交请求。然后解析程序将当前包装`HttpServletRequest`成`MultipartHttpServletRequest`支持多部分文件上传的文件。使用这个`MultipartHttpServletRequest`，你可以得到关于这个请求所包含的多部分的信息，并且实际上可以在你的控制器中访问这个多部分文件。

#### 1.10.3。在*Servlet 3.0中*使用MultipartResolver

为了使用基于Servlet 3.0的多部分解析，您需要`DispatcherServlet`用一个`"multipart-config"`部分标记`web.xml`，或者`javax.servlet.MultipartConfigElement`在程序化的Servlet注册中标记 ，或者在Servlet类可能带有`javax.servlet.annotation.MultipartConfig` 注释的自定义Servlet类的情况下。配置设置（如最大大小或存储位置）需要在该Servlet注册级别应用，因为Servlet 3.0不允许从MultipartResolver完成这些设置。

一旦以上述方式之一启用了Servlet 3.0多部分解析，您可以将其添加`StandardServletMultipartResolver`到您的Spring配置中：

```xml
<bean id="multipartResolver"
                class="org.springframework.web.multipart.support.StandardServletMultipartResolver">
</bean>
```

#### 1.10.4。处理表单中的文件上传

在之后`MultipartResolver`完成了工作，请求处理像任何其他。首先，创建一个带有文件输入的表单，允许用户上传表单。编码属性（`enctype="multipart/form-data"`）让浏览器知道如何将表单编码为多部分请求：

```xml
<html>
        <head>
                <title>Upload a file please</title>
        </head>
        <body>
                <h1>Please upload a file</h1>
                <form method="post" action="/form" enctype="multipart/form-data">
                        <input type="text" name="name"/>
                        <input type="file" name="file"/>
                        <input type="submit"/>
                </form>
        </body>
</html>
```

下一步是创建一个处理文件上传的控制器。这个控制器非常类似于一个[正常的注释`@Controller`](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/web.html#mvc-ann-controller)，除了我们使用`MultipartHttpServletRequest`或者`MultipartFile`在方法参数：

```java
@Controller
public class FileUploadController {

        @PostMapping("/form")
        public String handleFormUpload(@RequestParam("name") String name,
                        @RequestParam("file") MultipartFile file) {

                if (!file.isEmpty()) {
                        byte[] bytes = file.getBytes();
                        // store the bytes somewhere
                        return "redirect:uploadSuccess";
                }

                return "redirect:uploadFailure";
        }
 
}
```

请注意，`@RequestParam`方法参数如何映射到表单中声明的输入元素。在这个例子中，没有做任何事情`byte[]`，但实际上你可以将它保存在数据库中，将它存储在文件系统中，等等。

请注意，`@RequestParam`方法参数如何映射到表单中声明的输入元素。在这个例子中，没有做任何事情`byte[]`，但实际上你可以将它保存在数据库中，将它存储在文件系统中，等等。

使用Servlet 3.0多部分解析时，您还可以使用`javax.servlet.http.Part`方法参数

**multipart-config所有的属性都是可选的，具体属性如下：**

- fileSizeThreshold: int 当数据量大于该值时，内容将被写入文件，默认值为0bytes
- location: String 存放生成的文件地址，默认值为“”，文件地址是文件系统里的据对路径，它不支持相对路径，所以一般不要配置它
- maxFileSize: long 允许上传的文件最大值。默认值为 -1，表示没有限制。
- maxRequestSize: long 针对该 multipart/form-data 请求的最大数量，默认值为 -1，表示没有限制。

`@Value("${save.directory}")`在`controller`引用`propertyPlayceHodlerConfiger`配置的属性值

#### 1.10.5。处理来自编程客户端的文件上传请求

多部分请求也可以在非RESTful服务场景中从非浏览器客户端提交。以上所有示例和配置都适用于此。但是，与通常提交文件和简单表单域的浏览器不同，编程客户机还可以发送特定内容类型的更复杂的数据，例如带有文件的多部分请求和带有JSON格式数据的第二部分：

```
POST / someUrl 
Content-Type：multipart / mixed 

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp 
Content-Disposition：form-data; name =“meta-data” 
Content-Type：application / json; charset = UTF-8 
Content-Transfer-Encoding：8bit 

{ 
	“name”：“value” 
} 
--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp 
Content-Disposition：form-data; NAME =“文件的数据”; 文件名=“file.properties” 
内容类型：文本/ XML 
内容传输编码：8位
...文件数据...
```

您可以使用`@RequestParam("meta-data") String metadata`控制器方法参数访问名为“元数据”的部分。但是，您可能更愿意接受从请求部分的主体中的JSON格式的数据初始化的强类型对象，这非常类似于`@RequestBody`借助于将非多部分请求的主体转换为目标对象的方式`HttpMessageConverter`。

您可以使用`@RequestPart`注释来代替`@RequestParam`注释来实现此目的。它允许您通过`HttpMessageConverter`考虑`'Content-Type'`多部分的头部来传递特定多部分的内容：

```
@PostMapping("/someUrl")
public String onSubmit(@RequestPart("meta-data") MetaData metadata,
                @RequestPart("file-data") MultipartFile file) {

        // ...

}
```

请注意，`MultipartFile`方法参数可以通过`@RequestParam`或可以 `@RequestPart`互换地访问。然而，`@RequestPart("meta-data") MetaData`在这种情况下，方法参数被读作JSON内容的基础上它的`'Content-Type'`头和转换的帮助`MappingJackson2HttpMessageConverter`。

### 1.11。处理异常

#### 1.11.1。HandlerExceptionResolver

Spring `HandlerExceptionResolver`实现处理控制器执行期间发生的意外异常。一个`HandlerExceptionResolver`有点象异常映射的，你可以在Web应用程序描述符定义`web.xml`。但是，它们提供了一种更灵活的方式。例如，它们提供有关在抛出异常时执行哪个处理程序的信息。此外，处理异常的编程方式为您提供了更多的选择，以便在将请求转发到另一个URL（与使用Servlet特定的异常映射时相同的最终结果）之前做出适当的响应。

- 除了实现`HandlerExceptionResolver`接口，这只是实现`resolveException(Exception, Handler)`方法和返回的一个问题`ModelAndView`，

- 你也可以使用提供的`SimpleMappingExceptionResolver`或创建 `@ExceptionHandler`方法。将`SimpleMappingExceptionResolver`让您采取可能被抛出的异常的类名，并将它映射到视图名。

  这在功能上等同于Servlet API的异常映射功能，但是也可以从不同的处理程序实现更多细化的异常映射。

  ​

  - `@ExceptionHandler`另一方面，注释可用于应该被调用来处理异常的方法。这些方法可以在本地内定义，`@Controller`或者可以适用`@Controller`于在`@ControllerAdvice`类中定义的许多类。以下部分更详细地解释了这一点。

#### 1.11.2。@ExceptionHandler

- 在控制器中声明 `@ExceptionHandler()`注解的方法

  > 只在该控制器中有效

  ```java
  @ExceptionHandler(Exception.class)
  public String exceptionHandler(Exception ex,Model model){
    model.addAttributes("error",ex);
    return "error";//视图名
  }
  ```

- 在 `@ControllerAdvice`注解的类中定义 `@ExceptionHandler`

  > 在所有控制器中有效。【全局】



​	该`@ExceptionHandler`值可以设置为一个Exception类型的数组。如果抛出的异常与列表中的某个类型相匹配，`@ExceptionHandler`则将调用通过匹配注释的方法。如果未设置注释值，则使用列为方法参数的异常类型。

很像使用注释标注的标准控制器方法`@RequestMapping`，方法参数和方法的返回值`@ExceptionHandler`可以很灵活。例如，`HttpServletRequest`可以在Servlet环境中访问。返回类型可以是a `String`，它被解释为视图名称，`ModelAndView`对象，`ResponseEntity`或者也可以添加`@ResponseBody`以使方法返回值与消息转换器一起转换并写入响应流。



#### 1.11.3。处理标准的Spring MVC异常

`DefaultHandlerExceptionResolver`

`SimpleMappingExceptionResolver`

`ResponseEntityExceptionHandler`

在处理请求时，Spring MVC可能会引发一些异常。`SimpleMappingExceptionResolver`可以根据 需要轻松将任何异常映射到默认错误视图。但是，在与自动解释响应的客户合作时，您需要在响应中设置特定的状态码。取决于引发的异常，状态码可能指示客户端错误（4xx）或服务器错误（5xx）。

该`DefaultHandlerExceptionResolver`转换Spring MVC的例外特定的错误状态代码。默认情况下，它是通过MVC命名空间，MVC Java配置以及`DispatcherServlet`（即不使用MVC命名空间或Java配置时）注册的。下面列出了该解析器处理的一些例外情况以及相应的状态码：

| 例外                                       | HTTP状态码       |
| ---------------------------------------- | ------------- |
| `BindException`                          | 400（坏请求）      |
| `ConversionNotSupportedException`        | 500内部服务器错误）   |
| `HttpMediaTypeNotAcceptableException`    | 406（不可接受）     |
| `HttpMediaTypeNotSupportedException`     | 415（不支持的媒体类型） |
| `HttpMessageNotReadableException`        | 400（坏请求）      |
| `HttpMessageNotWritableException`        | 500内部服务器错误）   |
| `HttpRequestMethodNotSupportedException` | 405（方法不允许）    |
| `MethodArgumentNotValidException`        | 400（坏请求）      |
| `MissingPathVariableException`           | 500内部服务器错误）   |
| `MissingServletRequestParameterException` | 400（坏请求）      |
| `MissingServletRequestPartException`     | 400（坏请求）      |
| `NoHandlerFoundException`                | 404（未找到）      |
| `NoSuchRequestHandlingMethodException`   | 404（未找到）      |
| `TypeMismatchException`                  | 400（坏请求）      |

如果你喜欢通过`@ExceptionHandler`方法编写错误内容，你可以扩展 `ResponseEntityExceptionHandler`。这是`@ControllerAdvice`提供`@ExceptionHandler`处理标准Spring MVC异常和返回的方法的类的便利基础 `ResponseEntity`。这使您可以自定义响应并使用消息转换器编写错误内容。有关`ResponseEntityExceptionHandler`更多详细信息，请参阅 javadocs。

#### 1.11.4。REST控制器异常处理

一个`@RestController`可以使用`@ExceptionHandler`返回一个方法， `ResponseEntity`在响应的主体既提供响应状态和错误的详细信息。这些方法也可以添加到`@ControllerAdvice` 子类或所有控制器的异常处理类中。

一个常见的要求是在响应的主体中包含错误细节。Spring不会自动执行此操作（虽然Spring Boot会这样做），因为响应主体中错误详细信息的表示方式是特定于应用程序的。

希望在响应主体中实现具有错误细节的全局异常处理策略的应用程序应考虑扩展抽象基类`ResponseEntityExceptionHandler`，该类提供对Spring MVC引发的异常的处理，并提供钩子来自定义响应主体以及处理其他异常。只需将扩展类声明为Spring bean并使用它进行注释`@ControllerAdvice`。欲了解更多详情，请参阅`ResponseEntityExceptionHandler`。

#### 1.11.5。使用@ResponseStatus注释业务异常

业务异常可以使用注释`@ResponseStatus`。当引发异常时，`ResponseStatusExceptionResolver`通过相应地设置响应的状态来处理它。默认情况下，它可以使用的`DispatcherServlet`寄存器 `ResponseStatusExceptionResolver`。

#### 1.11.6。定制默认Servlet容器错误页面

当响应的状态设置为错误状态码并且响应的主体为空时，Servlet容器通常会呈现HTML格式的错误页面。要自定义容器的默认错误页面，可以在其中声明`<error-page>` 元素`web.xml`。直到Servlet 3，该元素必须映射到特定的状态码或异常类型。从Servlet 3开始，不需要映射错误页面，这实际上意味着指定的位置会自定义默认的Servlet容器错误页面。

```xml
<!-- springmvc提供的简单异常处理器 -->
<bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
     <!-- 定义默认的异常处理页面 -->
    <property name="defaultErrorView" value="/WEB-INF/jsp/error.jsp"/>
    <!-- 定义异常处理页面用来获取异常信息的变量名，也可不定义，默认名为exception --> 
    <property name="exceptionAttribute" value="ex"/>
    <!-- 定义需要特殊处理的异常，这是重要点 --> 
    <property name="exceptionMappings">
        <props>
            <prop key="ssm.exception.CustomException">/WEB-INF/jsp/custom_error.jsp</prop>
        </props>
        <!-- 还可以定义其他的自定义异常 -->
    </property>
</bean>
```

当响应的状态设置为错误状态码并且响应的主体为空时，Servlet容器通常会呈现HTML格式的错误页面。要自定义容器的默认错误页面，可以在其中声明`<error-page>` 元素`web.xml`。直到Servlet 3，该元素必须映射到特定的状态码或异常类型。从Servlet 3开始，不需要映射错误页面，这实际上意味着指定的位置会自定义默认的Servlet容器错误页面。

```
<error-page>
        <location>/error</location>
</error-page>
```

请注意，错误页面的实际位置可以是容器内的JSP页面或其他URL，包括通过`@Controller`方法处理的URL ：

在写入错误信息时，`HttpServletResponse`可以通过控制器中的请求属性访问设置在其上的状态代码和错误消息 ：

```
@Controller
public class ErrorController {

        @RequestMapping(path = "/error", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
        @ResponseBody
        public Map<String, Object> handle(HttpServletRequest request) {

                Map<String, Object> map = new HashMap<String, Object>();
                map.put("status", request.getAttribute("javax.servlet.error.status_code"));
                map.put("reason", request.getAttribute("javax.servlet.error.message"));

                return map;
        }

}
```

或者在JSP中：

```
<%@ page contentType="application/json" pageEncoding="UTF-8"%>
{
        status:<%=request.getAttribute("javax.servlet.error.status_code") %>,
        reason:<%=request.getAttribute("javax.servlet.error.message") %>
}
```

### 1.12。网络安全

在[春季安全](https://projects.spring.io/spring-security/)项目提供的功能，以防止恶意攻击Web应用程序。查看[“CSRF保护”](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#csrf)， [“安全响应头”](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers)以及 [“Spring MVC集成”](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#mvc)部分的参考文档 。请注意，使用Spring Security来保护应用程序不一定需要所有功能。例如，只需通过将`CsrfFilter`和 添加`CsrfRequestDataValueProcessor`到您的配置中即可添加CSRF保护。有关 示例，请参阅 [Spring MVC展示](https://github.com/spring-projects/spring-mvc-showcase/commit/361adc124c05a8187b84f25e8a57550bb7d9f8e4)。

另一种选择是使用专门用于网络安全的框架。 [HDIV](http://hdiv.org/)是一个这样的框架，并与Spring MVC集成。

### 1.13。约定优于配置支持

Convention-over-configuration支持解决了MVC的三个核心领域：模型，视图和控制器。

#### 1.13.1。Controller ControllerClassNameHandlerMapping

该`ControllerClassNameHandlerMapping`班是一个`HandlerMapping`使用惯例来确定请求的URL和之间的映射实现`Controller`是要处理这些请求的情况。

考虑以下简单的`Controller`实现。请特别注意班级的 *名字*。

```
public class ViewShoppingCartController implements Controller {

        public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) {
                // the implementation is not hugely important for this example...
        }

}
```

这里是相应的Spring Web MVC配置文件的一个片段：

```
<bean class="org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping"/>

<bean id="viewShoppingCart" class="x.y.z.ViewShoppingCartController">
        <!-- inject dependencies as required... -->
</bean>
```

在`ControllerClassNameHandlerMapping`找出所有的处理程序（或 `Controller`在其应用上下文定义的）豆和剥离`Controller`掉，以限定其处理程序映射的名称。因此，`ViewShoppingCartController`映射到 `/viewshoppingcart*`请求URL。

让我们看看更多的例子，以便中心思想立刻变得熟悉。（请注意URL中的所有小写字母，与骆驼`Controller`类名称相反）。

- `WelcomeController`映射到`/welcome*`请求URL
- `HomeController`映射到`/home*`请求URL
- `IndexController`映射到`/index*`请求URL
- `RegisterController`映射到`/register*`请求URL

在`MultiActionController`处理程序类的情况下，生成的映射稍微复杂一些。`Controller`以下示例中的名称假定为`MultiActionController`实现：

- `AdminController`映射到`/admin/*`请求URL
- `CatalogController`映射到`/catalog/*`请求URL

如果你按照惯例命名你的`Controller`实现 `xxxController`，那么`ControllerClassNameHandlerMapping`你可以节省定义和维护一个潜在的*looooong* `SimpleUrlHandlerMapping`（或类似的）的乏味。

本`ControllerClassNameHandlerMapping`类扩展`AbstractHandlerMapping`基类，所以你可以定义`HandlerInterceptor`实例和一切，就像你与许多其他`HandlerMapping`的实现。

#### 1.13.2。Model ModelMap（ModelAndView）

这个`ModelMap`类本质上是一种荣耀`Map`，它可以使要添加的对象在`View`一个通用的命名约定中（或在其上）显示。考虑下面的`Controller`实现; 请注意，对象将添加到`ModelAndView`没有指定任何关联名称的对象 。

```
public class DisplayShoppingCartController implements Controller {

        public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) {

                List cartItems = // get a List of CartItem objects
                User user = // get the User doing the shopping

                ModelAndView mav = new ModelAndView("displayShoppingCart"); <-- the logical view name

                mav.addObject(cartItems); <-- look ma, no name, just the object
                mav.addObject(user); <-- and again ma!

                return mav;
        }
}
```

的`ModelAndView`类使用一个`ModelMap`类，它是一个自定义的`Map`，可自动生成用于当对象被添加到它的对象的键实现。在标量对象的情况下，用于确定添加对象名称的策略是`User`使用对象类的简短类名称。以下示例是为放入`ModelMap`实例的标量对象生成的名称。

- `x.y.User`添加的实例将`user`生成名称。
- `x.y.Registration`添加的实例将`registration`生成名称。
- `x.y.Foo`添加的实例将`foo`生成名称。
- `java.util.HashMap`添加的实例将`hashMap`生成名称。您可能希望在这种情况下明确名称，因为`hashMap`它不够直观。
- 添加`null`会导致`IllegalArgumentException`被抛出。如果您添加的对象（或对象）可能是`null`，那么您还需要明确名称。

添加a `Set`或a 之后生成名称的策略`List`是查看集合，获取集合中第一个对象的简短类名称，并使用`List`该名称附加到名称上。这同样适用于数组，虽然使用数组不需要查看数组内容。一些例子会使集合的名称生成的语义更清晰：

- 添加`x.y.User[]`零个或多个`x.y.User`元素的数组将会`userList`生成名称 。
- 添加`x.y.Foo[]`零个或多个`x.y.User`元素的数组将会`fooList`生成名称 。
- 添加`java.util.ArrayList`了一个或多个`x.y.User`元素的A 将`userList`生成名称 。
- 添加`java.util.HashSet`了一个或多个`x.y.Foo`元素的A 将`fooList`生成名称 。
- 一个*空的* `java.util.ArrayList`将不会被添加（实际上，这个 `addObject(..)`调用本质上是一个空操作）。

#### 1.13.3。View - RequestToViewNameTranslator

当没有明确提供这样的逻辑视图名称时，`RequestToViewNameTranslator`接口确定一个逻辑`View`名称。它只有一个实现，即`DefaultRequestToViewNameTranslator`类。

该`DefaultRequestToViewNameTranslator`示例请求URL到逻辑视图名称，如下例所示：

```
public class RegistrationController implements Controller {

        public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) {
                // process the request...
                ModelAndView mav = new ModelAndView();
                // add data as necessary to the model...
                return mav;
                // notice that no View or logical view name has been set
        }

}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="
                http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans.xsd">

        <!-- this bean with the well known name generates view names for us -->
        <bean id="viewNameTranslator"
                        class="org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator"/>

        <bean class="x.y.RegistrationController">
                <!-- inject dependencies as necessary -->
        </bean>

        <!-- maps request URLs to Controller names -->
        <bean class="org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping"/>

        <bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
                <property name="prefix" value="/WEB-INF/jsp/"/>
                <property name="suffix" value=".jsp"/>
        </bean>

</beans>
```

### 1.14。HTTP缓存支持

一个好的HTTP缓存策略可以显着提高Web应用程序的性能和客户的体验。所述`'Cache-Control'`HTTP响应报头主要是为这个负责，使用条件报头，例如沿`'Last-Modified'`和`'ETag'`。

该`'Cache-Control'`HTTP响应头劝告私有的高速缓存（如浏览器），以及他们如何缓存进一步重用HTTP响应的公共高速缓存（例如代理）

一个[的ETag](https://en.wikipedia.org/wiki/HTTP_ETag)（实体标签）是由HTTP / 1.1兼容的Web用于在给定的URL来确定内容改变服务器返回的HTTP响应报头中。它可以被认为是`Last-Modified`标题的更复杂的后继者 。当服务器使用ETag头返回一个表示时，客户端可以在后面的GET中使用这个`If-None-Match`头。如果内容没有改变，服务器返回`304: Not Modified`。

#### 1.14.1。缓存控制HTTP标头

Spring Web MVC支持许多用例以及为应用程序配置“Cache-Control”头的方法。虽然[RFC 7234第5.2.2节](https://tools.ietf.org/html/rfc7234#section-5.2.2) 完全描述了该头文件及其可能的指令，但有几种方法可以解决最常见的情况。

Spring Web MVC在其几个API中使用了一个配置约定 `setCachePeriod(int seconds)`：

- 甲`-1`值将不生成`'Cache-Control'`响应头。
- 一个`0`值，将使用防止缓存`'Cache-Control: no-store'`指令。
- 一个`n > 0`值将`n`使用`'Cache-Control: max-age=n'`指令缓存给定的响应秒数 。

该[`CacheControl`](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/javadoc-api/org/springframework/http/CacheControl.html)生成器类简单地描述了可用的“缓存控制”指令，并使其更容易建立自己的HTTP缓存策略。一旦构建完成，一个`CacheControl`实例可以被接受为几个Spring Web MVC API中的一个参数。

```java
// Cache for an hour - "Cache-Control: max-age=3600"
   CacheControl ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS);

   // Prevent caching - "Cache-Control: no-store"
   CacheControl ccNoStore = CacheControl.noStore();

   // Cache for ten days in public and private caches,
   // public caches should not transform the response
   // "Cache-Control: max-age=864000, public, no-transform"
   CacheControl ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS)
                                                                           .noTransform().cachePublic();
```

#### 1.14.2。HTTP缓存支持静态资源

应该为静态资源提供适当的`'Cache-Control'`条件标题以获得最佳性能。 [配置一个`ResourceHttpRequestHandler`](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/web.html#mvc-config-static-resources) for serving静态资源不仅`'Last-Modified'`通过读取文件的元数据本地写入标题，而且`'Cache-Control'`如果配置正确，还可以标题。

您可以`cachePeriod`在a上设置属性`ResourceHttpRequestHandler`或使用`CacheControl`支持更多特定指令的实例：

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

        @Override
        public void addResourceHandlers(ResourceHandlerRegistry registry) {
                registry.addResourceHandler("/resources/**")
                                .addResourceLocations("/public-resources/")
                                .setCacheControl(CacheControl.maxAge(1, TimeUnit.HOURS).cachePublic());
        }

}
```

在XML中：

```xml
<mvc:resources mapping="/resources/**" location="/public-resources/">
        <mvc:cache-control max-age="3600" cache-public="true"/>
</mvc:resources>
```

#### 1.14.3。在控制器中支持Cache-Control，ETag和Last-Modified响应头

#### 1.14.3。在控制器中支持Cache-Control，ETag和Last-Modified响应头

控制器可以支持`'Cache-Control'`，`'ETag'`和/或`'If-Modified-Since'`HTTP请求; 如果`'Cache-Control'`要在响应中设置标题，这确实是推荐的。这包括计算`long`给定请求的lastModified 和/或Etag值，将其与`'If-Modified-Since'`请求标头值进行比较，并可能返回状态码为304（未修改）的响应。

如[使用HttpEntity中所述](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/web.html#mvc-ann-httpentity)，控制器可以使用`HttpEntity`类型与请求/响应进行交互 。返回的控制器`ResponseEntity`可以包含HTTP缓存信息，如下所示：

```
@GetMapping("/book/{id}")
public ResponseEntity<Book> showBook(@PathVariable Long id) {

        Book book = findBook(id);
        String version = book.getVersion();

        return ResponseEntity
                                .ok()
                                .cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
                                .eTag(version) // lastModified is also available
                                .body(book);
}
```

这样做不仅会在响应中包含`'ETag'`和`'Cache-Control'`标题，而且如果客户端发送的条件标头与Controller设置的缓存信息相匹配，它还会将**响应转换为HTTP 304 Not Modified空的响应**。

一种`@RequestMapping`方法也可能希望支持相同的行为。这可以实现如下：

```
@RequestMapping
public String myHandleMethod(WebRequest webRequest, Model model) {

        long lastModified = // 1. application-specific calculation

        if (request.checkNotModified(lastModified)) {
                // 2. shortcut exit - no further processing necessary
                return null;
        }

        // 3. or otherwise further request processing, actually preparing content
        model.addAttribute(...);
        return "myViewName";
}
```

这里有两个关键要素：打电话`request.checkNotModified(lastModified)`和回电`null`。前者在返回之前设置适当的响应状态和标题`true`。后者与前者结合使得Spring MVC不再对请求进行进一步处理。

请注意，这有3种变体：

- `request.checkNotModified(lastModified)`与比较上次更改时间 `'If-Modified-Since'`或`'If-Unmodified-Since'`请求头
- `request.checkNotModified(eTag)`将eTag与`'If-None-Match'`请求标头进行比较
- `request.checkNotModified(eTag, lastModified)` 两者都有效，这意味着两个条件都应该是有效的

当接收到条件`'GET'`/ `'HEAD'`请求时，`checkNotModified`将检查资源是否未被修改，如果是，则会导致`HTTP 304 Not Modified`响应。在有条件`'POST'`/ `'PUT'`/ `'DELETE'`请求的情况下，`checkNotModified` 将检查资源是否未被修改，如果已经被修改，将导致 `HTTP 409 Precondition Failed`响应以防止并发修改。

#### 1.14.4。浅ETag支持

ETags支持由Servlet过滤器提供`ShallowEtagHeaderFilter`。它是一个普通的Servlet过滤器，因此可以与任何Web框架结合使用。该 `ShallowEtagHeaderFilter`滤波器产生所谓的浅ETag的（相对于深的ETag，稍后详细说明）。该过滤器缓存呈现JSP（或其他内容）的内容，产生超过其MD5哈希，并返回作为ETag头在回应中。下一次客户端发送对相同资源的请求时，它将使用该散列作为`If-None-Match`值。过滤器检测到这一点，再次呈现视图，并比较两个哈希值。如果它们相等，`304`则返回a。

请注意，此策略可节省网络带宽，但不会节省CPU，因为必须为每个请求计算完整响应。控制器级别的其他策略（如上所述）可以节省网络带宽并避免计算。

此过滤器有一个`writeWeakETag`参数，用于配置过滤器以写入Weak ETags，如下所示：`W/"02a2d595e6ed9a0b24f027f2b63b134d6"`，如[RFC 7232第2.3节中](https://tools.ietf.org/html/rfc7232#section-2.3)所定义 。

你配置`ShallowEtagHeaderFilter`在`web.xml`：

```
<filter>
        <filter-name>etagFilter</filter-name>
        <filter-class>org.springframework.web.filter.ShallowEtagHeaderFilter</filter-class>
        <!-- Optional parameter that configures the filter to write weak ETags
        <init-param>
               <param-name>writeWeakETag</param-name>
               <param-value>true</param-value>
        </init-param>
        -->
</filter>

<filter-mapping>
        <filter-name>etagFilter</filter-name>
        <servlet-name>petclinic</servlet-name>
</filter-mapping>
```

或者在Servlet 3.0+环境中，

```
public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {

        // ...

        @Override
        protected Filter[] getServletFilters() {
                return new Filter[] { new ShallowEtagHeaderFilter() };
        }

}
```

查看[基于代码的Servlet容器初始化](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/web.html#mvc-container-config)以获取更多详细信息。

### 1.15。基于代码的Servlet容器初始化

在Servlet 3.0+环境中，您可以选择以编程方式配置Servlet容器作为备选项或与`web.xml`文件结合使用。以下是注册一个例子`DispatcherServlet`：

```java
import org.springframework.web.WebApplicationInitializer;

public class MyWebApplicationInitializer implements WebApplicationInitializer {

        @Override
        public void onStartup(ServletContext container) {
                XmlWebApplicationContext appContext = new XmlWebApplicationContext();
                appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");

                ServletRegistration.Dynamic registration = container.addServlet("dispatcher", new DispatcherServlet(appContext));
                registration.setLoadOnStartup(1);
                registration.addMapping("/");
        }

}
```

`WebApplicationInitializer`是Spring MVC提供的一个接口，它确保您的实现被检测到并自动用于初始化任何Servlet 3容器。的抽象基类实现`WebApplicationInitializer`名为 `AbstractDispatcherServletInitializer`使得它更容易注册`DispatcherServlet`，只需重写方法来指定servlet映射和位置`DispatcherServlet`配置。

建议使用基于Java的Spring配置的应用程序：

```java
public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

        @Override
        protected Class<?>[] getRootConfigClasses() {
                return null;
        }

        @Override
        protected Class<?>[] getServletConfigClasses() {
                return new Class[] { MyWebConfig.class };
        }

        @Override
        protected String[] getServletMappings() {
                return new String[] { "/" };
        }

}
```

如果使用基于XML的Spring配置，则应直接从`AbstractDispatcherServletInitializer`以下位置扩展 ：

```java
public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {

        @Override
        protected WebApplicationContext createRootApplicationContext() {
                return null;
        }

        @Override
        protected WebApplicationContext createServletApplicationContext() {
                XmlWebApplicationContext cxt = new XmlWebApplicationContext();
                cxt.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");
                return cxt;
        }

        @Override
        protected String[] getServletMappings() {
                return new String[] { "/" };
        }

}
```

`AbstractDispatcherServletInitializer`还提供了添加`Filter` 实例并将其自动映射到以下内容的便捷方式`DispatcherServlet`：

```java
public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {

        // ...

        @Override
        protected Filter[] getServletFilters() {
                return new Filter[] { new HiddenHttpMethodFilter(), new CharacterEncodingFilter() };
        }

}
```

该`isAsyncSupported`保护的方法`AbstractDispatcherServletInitializer` 提供了一个单一的地方，以使在异步支持`DispatcherServlet`并映射到它的所有过滤器。默认情况下，该标志设置为`true`。

最后，如果您需要进一步自定义`DispatcherServlet`自己，则可以覆盖该`createDispatcherServlet`方法。

### 1.16。配置Spring MVC

[特殊Bean类型在WebApplicationContext](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/web.html#mvc-servlet-special-bean-types)和[Default DispatcherServlet配置中](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/web.html#mvc-servlet-config)解释了关于Spring MVC的特殊bean以及使用的默认实现`DispatcherServlet`。在本节中，您将学习到另外两种配置Spring MVC的方法。即MVC Java配置和MVC XML命名空间。

MVC Java配置和MVC命名空间提供了覆盖`DispatcherServlet`默认值的类似默认配置。目标是让大多数应用程序不必创建相同的配置，并且提供更高级别的构造来配置Spring MVC，这些构造可以作为一个简单的起点，并且几乎不需要事先知道底层配置。

您可以根据您的偏好选择MVC Java配置或MVC命名空间。同样如您将在下面看到的，使用MVC Java配置，可以更容易地看到底层配置，以及直接对创建的Spring MVC bean进行细粒度的自定义。但是让我们从头开始。

#### .16.1。启用MVC Java配置或MVC XML命名空间

- 要启用MVC Java配置，请将注释添加`@EnableWebMvc`到您的某个 `@Configuration`类中：

```java
@Configuration
@EnableWebMvc
public class WebConfig {

}
```

- 要在XML中使用相同的`mvc:annotation-driven`元素，请使用DispatcherServlet上下文中的元素（或者如果您没有定义DispatcherServlet上下文，则使用您的根上下文中的元素）：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:mvc="http://www.springframework.org/schema/mvc"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="
                http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/mvc
                http://www.springframework.org/schema/mvc/spring-mvc.xsd">

        <mvc:annotation-driven/>

</beans>
```

上面注册了a `RequestMappingHandlerMapping`，a `RequestMappingHandlerAdapter`和`ExceptionHandlerExceptionResolver`（以及其他），以支持使用注释控制器方法处理请求，使用注释（如`@RequestMapping`，`@ExceptionHandler`）等。

它还可以实现以下功能：

1. 除了用于数据绑定的JavaBeans PropertyEditor外，还通过[ConversionService](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/core.html#core-convert)实例进行Spring 3样式类型转换。

2. 支持使用注释来[格式化](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/core.html#format)数字字段。`@NumberFormat``ConversionService`

3. 支持[的格式](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/core.html#format) `Date`，`Calendar`，`Long`，和乔达时间使用的字段 `@DateTimeFormat`注解。

4. 如果JSR-303提供程序存在于类路径中，则支持[验证](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/web.html#mvc-config-validation) `@Controller`输入`@Valid`。

5. `HttpMessageConverter`支持`@RequestBody`方法参数和`@ResponseBody` 方法返回来自`@RequestMapping`或`@ExceptionHandler`方法的值。

   这是由mvc设置的HttpMessageConverters的完整列表：annotation-driven：

   1. `ByteArrayHttpMessageConverter` 转换字节数组。
   2. `StringHttpMessageConverter` 转换字符串。
   3. `ResourceHttpMessageConverter`转换为/从 `org.springframework.core.io.Resource`所有媒体类型。
   4. `SourceHttpMessageConverter`转换成/来自a `javax.xml.transform.Source`。
   5. `FormHttpMessageConverter`将表单数据转换为/来自a `MultiValueMap<String, String>`。
   6. `Jaxb2RootElementHttpMessageConverter` 将Java对象转换为XML或从XML转换 - 如果存在JAXB2并且类路径中不存在Jackson 2 XML扩展，则添加该对象。
   7. `MappingJackson2HttpMessageConverter` 转换为/从JSON - 如果Jackson 2存在于类路径中，则添加。
   8. `MappingJackson2XmlHttpMessageConverter`转换为/从XML - 如果 [Jackson 2 XML扩展](https://github.com/FasterXML/jackson-dataformat-xml)存在于类路径中，则添加它。
   9. `MappingJackson2SmileHttpMessageConverter`转换为/从微笑（二进制JSON） - 如果 [Jackson 2 Smile扩展](https://github.com/FasterXML/jackson-dataformats-binary/tree/master/smile) 存在于类路径中，则添加。
   10. `MappingJackson2CborHttpMessageConverter`转换为/从CBOR - 如果 [Jackson 2 CBOR扩展](https://github.com/FasterXML/jackson-dataformats-binary/tree/master/cbor) 存在于类路径中，则添加。
   11. `AtomFeedHttpMessageConverter` 转换Atom提要 - 如果罗马存在于类路径中，则添加。
   12. `RssChannelHttpMessageConverter` 转换RSS源 - 如果罗马存在于类路径中，则添加它。

> | **   | Jackson JSON和XML转换器是使用`ObjectMapper`创建的实例创建的 [`Jackson2ObjectMapperBuilder`](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/javadoc-api/org/springframework/http/converter/json/Jackson2ObjectMapperBuilder.html) ，以提供更好的默认配置。该构建器使用以下几种方法自定义Jackson的默认属性：[`DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES`](https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/DeserializationFeature.html#FAIL_ON_UNKNOWN_PROPERTIES) 被禁用。[`MapperFeature.DEFAULT_VIEW_INCLUSION`](https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/MapperFeature.html#DEFAULT_VIEW_INCLUSION) 被禁用。如果在类路径中检测到它们，它还会自动注册下列已知模块：[jackson-datatype-jdk7](https://github.com/FasterXML/jackson-datatype-jdk7)：支持Java 7类型`java.nio.file.Path`。[jackson-datatype-joda](https://github.com/FasterXML/jackson-datatype-joda)：支持Joda-Time类型。[jackson-datatype-jsr310](https://github.com/FasterXML/jackson-datatype-jsr310)：支持Java 8日期和时间API类型。[jackson-datatype-jdk8](https://github.com/FasterXML/jackson-datatype-jdk8)：支持其他Java 8类型`Optional`。 |
> | ---- | ---------------------------------------- |
> |      |                                          |

#### 1.16.2。自定义提供的配置

要在Java中自定义默认配置，只需实现 `WebMvcConfigurer`接口，或者更可能扩展该类`WebMvcConfigurer` 并覆盖所需的方法：

```
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

        // Override configuration methods...

}
```

要自定义`<mvc:annotation-driven/>`检查它支持的属性和子元素的默认配置。您可以查看 [Spring MVC XML模式](https://schema.spring.io/mvc/spring-mvc.xsd)或使用IDE的代码完成功能来发现可用的属性和子元素。

#### 1.16.3。转换和格式化

默认情况下，安装了格式化程序for `Number`和`Date`类型，包括对`@NumberFormat`和`@DateTimeFormat`注释的支持。如果Joda时间存在于类路径中，则还会安装对Joda时间格式库的全面支持。要注册自定义格式化器和转换器，请覆盖该`addFormatters`方法：

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

        @Override
        public void addFormatters(FormatterRegistry registry) {
                // Add formatters and/or converters
        }

```
在MVC命名空间中，<mvc:annotation-driven>添加时会应用相同的默认值。要注册自定义格式化器和转换器，只需提供ConversionService：
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:mvc="http://www.springframework.org/schema/mvc"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="
                http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/mvc
                http://www.springframework.org/schema/mvc/spring-mvc.xsd">

        <mvc:annotation-driven conversion-service="conversionService"/>

        <bean id="conversionService"
                        class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
                <property name="converters">
                        <set>
                                <bean class="org.example.MyConverter"/>
                        </set>
                </property>
                <property name="formatters">
                        <set>
                                <bean class="org.example.MyFormatter"/>
                                <bean class="org.example.MyAnnotationFormatterFactory"/>
                        </set>
                </property>
                <property name="formatterRegistrars">
                        <set>
                                <bean class="org.example.MyFormatterRegistrar"/>
                        </set>
                </property>
        </bean>

</beans>
```
请参阅[FormatterRegistrar SPI](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/core.html#format-FormatterRegistrar-SPI) 和`FormattingConversionServiceFactoryBean`有关何时使用FormatterRegistrars的更多信息。

#### 1.16.4。验证

Spring提供了一个[Validator接口](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/core.html#validator)，可用于应用程序所有层的验证。在Spring MVC，您可以使用配置它作为一个全球性的`Validator`情况下，每当使用`@Valid`或`@Validated`遇到控制器方法的参数，和/或作为本地 `Validator`通过控制器内的`@InitBinder`方法。全局和本地验证器实例可以组合起来提供复合验证。

Spring还[支持JSR-303 / JSR-349](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/core.html#validation-beanvalidation-overview) Bean验证，通过`LocalValidatorFactoryBean`它将Spring `org.springframework.validation.Validator` 接口调整为Bean验证`javax.validation.Validator`合同。这个类可以作为全局验证器插入到Spring MVC中，如下所述。

默认情况下，通过在类路径中检测到Bean验证提供程序（如Hibernate验证程序）时，使用`@EnableWebMvc`或`<mvc:annotation-driven>`自动注册Spring MVC中的Bean验证支持`LocalValidatorFactoryBean`。

有时`LocalValidatorFactoryBean`注入控制器或其他类会很方便。最简单的方法是声明你自己的`@Bean`并且标记它`@Primary`以避免与MVC Java配置提供的相冲突。

> 如果您更喜欢使用MVC Java配置中的那个，那么您需要重写 `mvcValidator`方法`WebMvcConfigurationSupport`并声明该方法显式返回`LocalValidatorFactory`而不是`Validator`。有关 如何切换以扩展提供的配置的信息，请参阅[使用MVC Java配置的高级自定义](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/web.html#mvc-config-advanced-java)。

- 您可以配置您自己的全局`Validator`实例：

  ```java
  @Configuration
  @EnableWebMvc
  public class WebConfig implements WebMvcConfigurer {

          @Override
          public Validator getValidator(); {
                  // return "global" validator
          }

  }
  ```

  并在XML中：

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:mvc="http://www.springframework.org/schema/mvc"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="
                  http://www.springframework.org/schema/beans
                  http://www.springframework.org/schema/beans/spring-beans.xsd
                  http://www.springframework.org/schema/mvc
                  http://www.springframework.org/schema/mvc/spring-mvc.xsd">

          <mvc:annotation-driven validator="globalValidator"/>

  </beans>
  ```

- 要将全局和本地验证结合起来，只需添加一个或多个本地验证程序即可：

  ```java
  @Controller
  public class MyController {

          @InitBinder
          protected void initBinder(WebDataBinder binder) {
                  binder.addValidators(new FooValidator());
          }

  }
  ```

  与此最小配置的任何时间`@Valid`或`@Validated`遇到方法参数，它会被配置成验证器进行验证。任何验证违规将自动`BindingResult`作为方法参数的可访问错误暴露，并且也可在Spring MVC HTML视图中呈现。

#### 1.16.5。拦截器

您可以配置`HandlerInterceptors`或`WebRequestInterceptors`应用于所有传入请求或限制为特定的URL路径模式。

在Java中注册拦截器的示例：

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

        @Override
        public void addInterceptors(InterceptorRegistry registry) {
                registry.addInterceptor(new LocaleInterceptor());
                registry.addInterceptor(new ThemeInterceptor()).addPathPatterns("/**").excludePathPatterns("/admin/**");
                registry.addInterceptor(new SecurityInterceptor()).addPathPatterns("/secure/*");
        }

}
```

在XML中使用`<mvc:interceptors>`元素：

```xml
<mvc:interceptors>
        <bean class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"/>
        <mvc:interceptor>
                <mvc:mapping path="/**"/>
                <mvc:exclude-mapping path="/admin/**"/>
                <bean class="org.springframework.web.servlet.theme.ThemeChangeInterceptor"/>
        </mvc:interceptor>
        <mvc:interceptor>
                <mvc:mapping path="/secure/*"/>
                <bean class="org.example.SecurityInterceptor"/>
        </mvc:interceptor>
</mvc:interceptors>
```

#### 1.16.6。内容谈判

您可以配置Spring MVC如何根据请求确定请求的媒体类型。可用的选项是检查查询参数，文件扩展名的URL路径，“Accept”标头，使用固定列表还是自定义策略。

默认情况下，为了向后兼容，首先检查请求URI中的路径扩展，然后再检查“Accept”标头。但是，如果您必须使用基于URL的内容类型解析，我们强烈建议在路径扩展上使用查询参数策略，因为后者可能会导致URI变量，路径参数以及URI解码相结合的问题。

在MVC的Java配置和MVC命名寄存器`json`，`xml`，`rss`，`atom`在默认情况下，如果相应的依赖都在类路径中。额外的路径扩展到媒体类型映射也可以被明确注册，并且还具有将它们作为用于RFD攻击检测目的的安全扩展白名单的效果（参见[后缀模式匹配和RFD](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/web.html#mvc-ann-requestmapping-rfd)以获得更多细节）。

以下是通过MVC Java配置自定义内容协商选项的示例：

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

        @Override
        public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
                configurer.mediaType("json", MediaType.APPLICATION_JSON);
        }
}
```

在MVC命名空间中，该`<mvc:annotation-driven>`元素具有一个`content-negotiation-manager`属性，该属性预计`ContentNegotiationManager` 可以使用以下 属性创建`ContentNegotiationManagerFactoryBean`：

```xml
<mvc:annotation-driven content-negotiation-manager="contentNegotiationManager"/>

<bean id="contentNegotiationManager" class="org.springframework.web.accept.ContentNegotiationManagerFactoryBean">
        <property name="mediaTypes">
                <value>
                        json=application/json
                        xml=application/xml
                </value>
        </property>
</bean>
```

如果不使用MVC Java配置或MVC命名空间，则需要创建一个实例`ContentNegotiationManager`并将其用于配置`RequestMappingHandlerMapping` 请求映射，`RequestMappingHandlerAdapter`以及 `ExceptionHandlerExceptionResolver`用于内容协商。

请注意，`ContentNegotiatingViewResolver`现在也可以使用a配置 `ContentNegotiationManager`，因此您可以在整个Spring MVC中使用一个共享实例。

在更高级的情况下，配置`ContentNegotiationManager`可能包含自定义`ContentNegotiationStrategy`实现的多个实例 可能会很有用 。例如，你可以配置 `ExceptionHandlerExceptionResolver`一个`ContentNegotiationManager`总是解析所请求的媒体类型`"application/json"`。或者，如果没有请求内容类型，您可能需要插入具有某种逻辑的自定义策略来选择默认内容类型（例如XML或JSON）。

#### 1.16.7。视图控制器

这是定义一个`ParameterizableViewController`调用时立即转到视图的快捷方式。如果在视图生成响应之前没有Java控制器逻辑要执行，则在静态情况下使用它。

将请求转发给在Java中`"/"`调用的视图的示例`"home"`：

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

        @Override
        public void addViewControllers(ViewControllerRegistry registry) {
                registry.addViewController("/").setViewName("home");
        }

}
```

在XML中使用相同的`<mvc:view-controller>`元素：

```xml
<mvc:view-controller path="/" view-name="home"/>
```

#### 1.16.8。查看解析器(MVC简化配置)

MVC配置简化了视图解析器的注册。

以下是一个Java配置示例，它使用FreeMarker HTML模板和Jackson作为`View`JSON呈现的默认配置来配置内容协商视图解析：

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

        @Override
        public void configureViewResolvers(ViewResolverRegistry registry) {
                registry.enableContentNegotiation(new MappingJackson2JsonView());
                registry.jsp();
        }

}
```

 和XML一样：

```xml
<mvc:view-resolvers>
        <mvc:content-negotiation>
                <mvc:default-views>
                        <bean class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"/>
                </mvc:default-views>
        </mvc:content-negotiation>
        <mvc:jsp/>
</mvc:view-resolvers>
```

但是请注意，FreeMarker，Tiles，Groovy Markup和脚本模板也需要配置底层视图技术。

MVC命名空间提供了专用元素。例如FreeMarker：

```xml
<mvc:view-resolvers>
        <mvc:content-negotiation>
                <mvc:default-views>
                        <bean class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"/>
                </mvc:default-views>
        </mvc:content-negotiation>
        <mvc:freemarker cache="false"/>
</mvc:view-resolvers>

<mvc:freemarker-configurer>
        <mvc:template-loader-path location="/freemarker"/>
</mvc:freemarker-configurer>
```

在Java配置中，只需添加相应的“配置器”bean：

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

        @Override
        public void configureViewResolvers(ViewResolverRegistry registry) {
                registry.enableContentNegotiation(new MappingJackson2JsonView());
                registry.freeMarker().cache(false);
        }

        @Bean
        public FreeMarkerConfigurer freeMarkerConfigurer() {
                FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
                configurer.setTemplateLoaderPath("/WEB-INF/");
                return configurer;
        }

}
```

#### 1.16.9。资源服务

此选项允许某个URL模式之后的静态资源请求由位置`ResourceHttpRequestHandler`列表中的任何`Resource`位置提供。这提供了一种便捷的方式来提供除Web应用程序根目录以外的位置（包括类路径上的位置）的静态资源。该`cache-period`属性可用于设置远期过期标题（1年是诸如Page Speed和YSlow等优化工具的建议），以便客户更有效地利用它们。处理程序还正确评估`Last-Modified`头（如果存在），以便`304`适当地返回状态码，避免客户端已缓存的资源产生不必要的开销。例如，要使用`/resources/**`来自某个 URL模式的资源请求`public-resources` 您将使用的Web应用程序根目录中的目录：

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

        @Override
        public void addResourceHandlers(ResourceHandlerRegistry registry) {
                registry.addResourceHandler("/resources/**").addResourceLocations("/public-resources/");
        }

}
```

和XML一样：

```xml
<mvc:resources mapping="/resources/**" location="/public-resources/"/>
```

要为这些资源提供1年的未来到期，以确保最大限度地利用浏览器缓存并减少浏览器发出的HTTP请求：

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

        @Override
        public void addResourceHandlers(ResourceHandlerRegistry registry) {
                registry.addResourceHandler("/resources/**").addResourceLocations("/public-resources/").setCachePeriod(31556926);
        }

}
```

在XML中：

```xml
<mvc:resources mapping="/resources/**" location="/public-resources/" cache-period="31556926"/>
```

该`mapping`属性必须是可以使用的Ant模式 `SimpleUrlHandlerMapping`，并且该`location`属性必须指定一个或多个有效的资源目录位置。多个资源位置可以使用逗号分隔的值列表指定。指定的位置将按照指定的顺序检查是否存在针对任何给定请求的资源。例如，要启用来自Web应用程序根目录和来自`/META-INF/public-web-resources/`classpath上任何jar 的已知路径的资源 ，请使用：

```java
@EnableWebMvc
@Configuration
public class WebConfig implements WebMvcConfigurer {

        @Override
        public void addResourceHandlers(ResourceHandlerRegistry registry) {
                registry.addResourceHandler("/resources/**")
                                .addResourceLocations("/", "classpath:/META-INF/public-web-resources/");
        }

}
```

在XML中：

```xml
<mvc:resources mapping="/resources/**" location="/, classpath:/META-INF/public-web-resources/"/>
```

当部署应用程序的新版本时可能会更改资源时，建议您将版本字符串并入用于请求资源的映射模式，以便您可以强制客户端请求新部署的应用程序资源版本。对版本化URL的支持已内置到框架中，并可通过在资源处理程序上配置资源链来启用。链由`ResourceResolver` 一个或多个`ResourceTransformer`实例后面的一个实例组成。他们一起可以提供任意的解决方案和资源转换。

内置`VersionResourceResolver`可以配置不同的策略。例如，`FixedVersionStrategy`可以使用属性，日期或其他作为版本。A `ContentVersionStrategy`使用从资源内容（称为“指纹识别”URL）计算出的MD5哈希值。请注意，`VersionResourceResolver`在服务资源时，将自动使用已解析的版本字符串作为HTTP ETag标头值。

`ContentVersionStrategy`是一个很好的默认选择，除非无法使用（例如，使用JavaScript模块加载器）。您可以针对不同的模式配置不同的版本策略，如下所示。请记住，计算基于内容的版本是昂贵的，因此应该在生产中启用资源链高速缓存。

Java配置示例;

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

        @Override
        public void addResourceHandlers(ResourceHandlerRegistry registry) {
                registry.addResourceHandler("/resources/**")
                                .addResourceLocations("/public-resources/")
                                .resourceChain(true).addResolver(
                                        new VersionResourceResolver().addContentVersionStrategy("/**"));
        }

}
```

XML示例：

```xml
<mvc:resources mapping="/resources/**" location="/public-resources/">
        <mvc:resource-chain>
                <mvc:resource-cache/>
                <mvc:resolvers>
                        <mvc:version-resolver>
                                <mvc:content-version-strategy patterns="/**"/>
                        </mvc:version-resolver>
                </mvc:resolvers>
        </mvc:resource-chain>
</mvc:resources>
```

为了上述工作，应用程序还必须呈现带有版本的URL。最简单的方法是配置 `ResourceUrlEncodingFilter`包装响应并覆盖其`encodeURL`方法。这可以在JSP，FreeMarker和任何其他视图技术中调用响应 `encodeURL`方法。或者，应用程序也可以直接注入并使用 `ResourceUrlProvider`bean，该bean通过MVC Java配置和MVC命名空间自动声明。

Webjars也支持`WebJarsResourceResolver`，当`"org.webjars:webjars-locator"`库在类路径上时它会自动注册。此解析器允许资源链从HTTP解析版本不可知的库，GET请求 `"GET /jquery/jquery.min.js"`将返回资源`"/jquery/1.2.0/jquery.min.js"`。它也可以通过在模板中重写资源URL来工作 `<script src="/jquery/jquery.min.js"/> → <script src="/jquery/1.2.0/jquery.min.js"/>`。

#### 1.16.10。回落到“默认”Servlet服务资源

这允许将映射`DispatcherServlet`到“/”（因此覆盖容器默认Servlet的映射），同时允许静态资源请求由容器的默认Servlet处理。它`DefaultServletHttpRequestHandler`使用“/ **”的URL映射和相对于其他URL映射的最低优先级来配置一个 。

该处理程序将把所有请求转发给默认的Servlet。因此，以所有其他网址的顺序保持最后是非常重要的`HandlerMappings`。这会是这样的，如果你使用`<mvc:annotation-driven>`或者相反，如果你设置你自己定制的`HandlerMapping`情况下，一定要设置其`order`属性为比的下一个值`DefaultServletHttpRequestHandler`，这是`Integer.MAX_VALUE`。

要使用默认设置启用该功能，请使用：

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

        @Override
        public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
                configurer.enable();
        }

}
```

或者在XML中：

```xml
<mvc:default-servlet-handler/>
```

覆盖“/”Servlet映射的注意事项是，`RequestDispatcher`默认的Servlet必须通过名称而不是路径来检索。该`DefaultServletHttpRequestHandler`会尝试自动检测在启动时容器中的默认的Servlet，使用大多数主要的Servlet容器（包括软件Tomcat，Jetty的GlassFish，JBoss和树脂中，WebLogic和WebSphere）已知名称的列表。如果默认的Servlet已经使用不同的名称进行了自定义配置，或者在默认的Servlet名称未知的情况下使用了不同的Servlet容器，则必须显式提供默认的Servlet名称，如下例所示：

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

        @Override
        public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
                configurer.enable("myCustomDefaultServlet");
        }

}
```

或者在XML中：

```xml
<mvc:default-servlet-handler default-servlet-name="myCustomDefaultServlet"/>
```

#### 1.16.11 路径匹配 (url--> 路径文件)

这允许自定义与URL映射和路径匹配相关的各种设置。有关各个选项的详细信息，请查看 [PathMatchConfigurer](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/javadoc-api/org/springframework/web/servlet/config/annotation/PathMatchConfigurer.html) API。

以下是Java配置中的一个例子：

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

        @Override
        public void configurePathMatch(PathMatchConfigurer configurer) {
                configurer
                    .setUseSuffixPatternMatch(true)
                    .setUseTrailingSlashMatch(false)
                    .setUseRegisteredSuffixPatternMatch(true)
                    .setPathMatcher(antPathMatcher())
                    .setUrlPathHelper(urlPathHelper());
        }

        @Bean
        public UrlPathHelper urlPathHelper() {
            //...
        }

        @Bean
        public PathMatcher antPathMatcher() {
            //...
        }

}
```

和XML一样，使用`<mvc:path-matching>`元素：

```xml
<mvc:annotation-driven>
    <mvc:path-matching
        suffix-pattern="true"
        trailing-slash="false"
        registered-suffixes-only="true"
        path-helper="pathHelper"
        path-matcher="pathMatcher"/>
</mvc:annotation-driven>

<bean id="pathHelper" class="org.example.app.MyPathHelper"/>
<bean id="pathMatcher" class="org.example.app.MyPathMatcher"/>
```

#### 1.16.12 消息转换器

如果您想替换Spring MVC创建的默认转换器，或者通过覆盖 如果您只是想定制它们或将其他转换器添加到默认转换器 ，`HttpMessageConverter`则可以在Java配置中实现 自定义。[`configureMessageConverters()`](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#configureMessageConverters-java.util.List-)[`extendMessageConverters()`](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#extendMessageConverters-java.util.List-)

下面是一个例子，它添加了Jackson JSON和XML转换器， `ObjectMapper`而不是默认的：

```java
@Configuration
@EnableWebMvc
public class WebConfiguration implements WebMvcConfigurer {

        @Override
        public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
                Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder()
                                .indentOutput(true)
                                .dateFormat(new SimpleDateFormat("yyyy-MM-dd"))
                                .modulesToInstall(new ParameterNamesModule());
                converters.add(new MappingJackson2HttpMessageConverter(builder.build()));
                converters.add(new MappingJackson2XmlHttpMessageConverter(builder.xml().build()));
        }

}
```

在此示例中，`Jackson2ObjectMapperBuilder`用于为两者创建通用配置，`MappingJackson2HttpMessageConverter`并`MappingJackson2XmlHttpMessageConverter`启用缩进，自定义日期格式以及 添加对访问参数名称（在Java 8中添加的功能）的支持的[jackson-module-parameter-names](https://github.com/FasterXML/jackson-module-parameter-names)的注册 。

> 使用Jackson XML支持启用缩进需要 [`woodstox-core-asl`](https://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.codehaus.woodstox%22%20AND%20a%3A%22woodstox-core-asl%22) 依赖于[`jackson-dataformat-xml`](https://search.maven.org/#search%7Cga%7C1%7Ca%3A%22jackson-dataformat-xml%22)另一个。
>
> 其他有趣的杰克逊模块可用：
>
> 1. [jackson-datatype-money](https://github.com/zalando/jackson-datatype-money)：支持`javax.money`类型（非官方模块）
> 2. [jackson-datatype-hibernate](https://github.com/FasterXML/jackson-datatype-hibernate)：支持Hibernate的特定类型和属性（包括延迟加载方面）

在XML中也可以做同样的事情：

```xml
<mvc:annotation-driven>
    <mvc:message-converters>
        <bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter">
            <property name="objectMapper" ref="objectMapper"/>
        </bean>
        <bean class="org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter">
            <property name="objectMapper" ref="xmlMapper"/>
        </bean>
    </mvc:message-converters>
</mvc:annotation-driven>

<bean id="objectMapper" class="org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"
      p:indentOutput="true"
      p:simpleDateFormat="yyyy-MM-dd"
      p:modulesToInstall="com.fasterxml.jackson.module.paramnames.ParameterNamesModule"/>

<bean id="xmlMapper" parent="objectMapper" p:createXmlMapper="true"/>
```

#### 1.16.13 使用MVC Java配置进行高级自定义

从上面的例子可以看出，MVC Java配置和MVC命名空间提供了更高层次的构造，不需要深入了解为您创建的底层bean。相反，它可以帮助您专注于您的应用程序需求。但是，在某些时候，您可能需要更细致的控制，或者您可能只想了解底层配置。

更细粒度控制的第一步是查看为您创建的底层bean。在MVC Java配置中，您可以看到javadoc和其中的`@Bean`方法`WebMvcConfigurationSupport`。该类中的配置通过`@EnableWebMvc`注释自动导入。事实上，如果你打开`@EnableWebMvc`你可以看到`@Import`声明。

更细粒度控制的下一步是定制其中一个在其中创建的bean的属性，`WebMvcConfigurationSupport`或者提供您自己的实例。这需要两件事 - 删除`@EnableWebMvc`注释，以防止导入，然后扩展`DelegatingWebMvcConfiguration`，的子类`WebMvcConfigurationSupport`。这里是一个例子：

```java
@Configuration
public class WebConfig extends DelegatingWebMvcConfiguration {

        @Override
        public void addInterceptors(InterceptorRegistry registry){
                // ...
        }

        @Override
        @Bean
        public RequestMappingHandlerAdapter requestMappingHandlerAdapter() {
                // Create or let "super" create the adapter
                // Then customize one of its properties
        }

}
```

> 一个应用程序应该只有一个配置扩展`DelegatingWebMvcConfiguration` 或一个`@EnableWebMvc`注释类，因为它们都注册了相同的底层bean。
>
> 以这种方式修改bean并不妨碍您使用本节前面所示的任何更高级别的构造。`WebMvcConfigurer`子类和`WebMvcConfigurer`实现仍在使用中。

#### 1.16.14 使用MVC命名空间进行高级自定义

对于为您创建的配置进行细粒度控制对于MVC命名空间有点困难。

如果您确实需要这样做，而不是复制它提供的配置，请考虑配置一个`BeanPostProcessor`检测要按类型自定义的bean，然后根据需要修改其属性的配置。例如：

```java
@Component
public class MyPostProcessor implements BeanPostProcessor {

        public Object postProcessBeforeInitialization(Object bean, String name) throws BeansException {
                if (bean instanceof RequestMappingHandlerAdapter) {
                        // Modify properties of the adapter
                }
        }

}
```

请注意，`MyPostProcessor`需要将其包含在一个`<component scan/>`中以便检测它，或者如果您愿意，可以使用XML bean声明来显式声明它。



