# 18.5视图

### 18.5.1使用ViewResolver界面解析视图

如[第18.3节，“实施控制器”](http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-controller)中所讨论的，Spring Web MVC控制器中的所有处理器方法必须明确地（例如，通过返回`String`，`View`或`ModelAndView`）或隐式地（即基于惯例）。 Spring中的视图由逻辑视图名称来解决，并由视图解析器解决。 Spring有不少解析器。 这个表格列出了其中的大部分; 下面有几个例子。

**Table18.3.查看解析器**

| 视图解析器                            | 描述                                       |
| :------------------------------- | :--------------------------------------- |
| `AbstractCachingViewResolver`    | 抽象视图解析器缓存视图。通常情况下，需要准备才能使用; 扩展此视图解析器提供缓存。 |
| `XmlViewResolver`                | `ViewResolver`的实现，它接受一个用XML编写的配置文件，其中使用与Spring的XML bean工厂相同的DTD。 默认配置文件是`/WEB-INF/views.xml`。 |
| `ResourceBundleViewResolver`     | `ViewResolver`的实现，它使用由bundle基名指定的`ResourceBundle`中的bean定义。 通常，您可以在位于类路径中的属性文件中定义该包。 默认文件名是`views.properties`。 |
| `UrlBasedViewResolver`           | `ViewResolver`接口的简单实现，它实现了逻辑视图名称直接解析到URL，而没有明确的映射定义。 如果您的逻辑名称以直观的方式与您的视图资源的名称相匹配，而不需要任意映射，则这是适当的。 |
| `InternalResourceViewResolver`   | `UrlBasedViewResolver`的便捷子类支持`InternalResourceView`（实际上是Servlet和JSP）和子类（如`JstlView`和`TilesView`）。 您可以使用`setViewClass(..)`为由此解析器生成的所有视图指定视图类。 有关详细信息，请参阅`UrlBasedViewResolver` javadocs。 |
| `FreeMarkerViewResolver`         | `UrlBasedViewResolver`方便的子类，支持`FreeMarkerView`和它们的自定义子类。 |
| `ContentNegotiatingViewResolver` | 实现基于请求文件名或`Accept`头来解析视图的`ViewResolver`接口。 请参见[第18.5.4节“ContentNegotiatingViewResolver”](https://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-multiple-representations)。 |

例如，使用JSP作为视图技术，可以使用`UrlBasedViewResolver`。此视图解析器将视图名称转换为URL，并将请求转交给`RequestDispatcher`以呈现视图。

```java
<bean id="viewResolver"
        class="org.springframework.web.servlet.view.UrlBasedViewResolver">
    <property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/>
    <property name="prefix" value="/WEB-INF/jsp/"/>
    <property name="suffix" value=".jsp"/>
</bean>
```

当将`test`作为逻辑视图名称返回时，此视图解析器将请求转发给`RequestDispatcher`，`RequestDispatcher`将请求发送到`/WEB-INF/jsp/test.jsp`。

### 18.5.2链接视图解析器

Spring支持多个视图解析器。 因此，您可以链接解析器，并在某些情况下覆盖特定的视图。 您可以通过向应用程序上下文中添加多个解析器来链接视图解析器，并在必要时通过设置`order`属性来指定排序。

 **请记住，`order`属性越高，视图解析器在链中的位置越晚。**

如果一个特定的视图解析器没有产生视图，Spring会检查其他视图解析器的上下文。 如果存在额外的视图解析器，Spring将继续检查它们，直到视图解决。 如果没有视图解析器返回一个视图，Spring会抛出一个`ServletException`异常。

视图解析器的合约指定一个视图resolver\_can\_return为null以指示视图找不到。 然而并不是所有的视图解析器都这样做，因为在某些情况下，解析器根本无法检测视图是否存在。 例如，`InternalResourceViewResolver`在内部使用`RequestDispatcher`，调度是确定JSP是否存在的唯一方法，但此操作只能执行一次。 `FreeMarkerViewResolver`和其他的一样。 检查特定视图解析器的javadoc以查看是否报告不存在的视图。 因此，将一个`InternalResourceViewResolver`放在链中的最后一个结果链中没有被完全检查，因为`InternalResourceViewResolver `will\_always\_return一个视图！

### 18.5.3 重定向到视图

如前所述，控制器通常返回一个逻辑视图名称，视图解析器解析为一个特定的视图技术。 对于通过Servlet或JSP引擎处理的JSP等视图技术，此解决方案通常通过`InternalResourceViewResolver`和`InternalResourceView`的组合来处理，`InternalResourceView`和`InternalResourceView`通过Servlet API的`RequestDispatcher.forward(..)`方法或`RequestDispatcher.include()`方法。 对于其他视图技术，如FreeMarker，XSLT等，视图本身直接将内容写入响应流。

- 在呈现视图之前，有时需要发送HTTP重定向回客户端。例如，当使用`POST`数据调用一个控制器时，这是可取的，而响应实际上是对另一个控制器的委托（例如成功的表单提交）。

>  在这种情况下，正常的内部转发意味着另一个控制器也会看到相同的`POST`数据，如果可能会将其与其他预期数据混淆，则这可能会造成问题。

>  在显示结果之前执行重定向的另一个原因是消除了用户多次提交表单数据的可能性。在这种情况下，浏览器将首先发送一个初始`POST`;它会接收到重定向到不同的URL的响应;最后浏览器会对重定向响应中的URL进行后续的`GET`操作。因此，从浏览器的角度来看，当前页面并不反映`POST`的结果，而是`GET`的结果。最终的效果是用户无法通过`POST`执行刷新而意外地重新发布相同的数据。刷新强制结果页面的`GET`，而不是重新发送初始`POST`数据。

#### RedirectView

作为控制器响应的结果，强制重定向的一种方法是让控制器创建并返回Spring的`RedirectView`实例。 在这种情况下，`DispatcherServlet`不使用普通视图解析机制。 而是因为它已经被赋予了（重定向）视图，`DispatcherServlet`只是指示视图来完成它的工作。 `RedirectView`依次调用`HttpServletResponse.sendRedirect()`向客户端浏览器发送HTTP重定向。

如果使用RedirectView并且视图是由控制器本身创建的，则建议您将重定向URL配置为注入控制器，以使其不会被烘焙到控制器中，而是在上下文中与视图名称一起配置。 在[一节“重定向：前缀”](http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-redirecting-redirect-prefix)有利于这种脱钩。

#### 将数据传递到重定向目标

默认情况下，所有的模型属性都被认为是作为重定向URL中的URI模板变量公开的。 其余属性是原始类型或集合/基本类型数组，都自动附加为查询参数。

如果为重定向专门准备了模型实例，那么将基元类型属性附加为查询参数可能是期望的结果。 但是，在带注解的控制器中，模型可能包含为渲染目的而添加的附加属性（例如，下拉字段值）。 为了避免在URL中出现这样的属性，`@RequestMapping`方法可以声明`RedirectAttributes`类型的参数，并使用它来指定可用于`RedirectView`的确切属性。 如果方法确实重定向，则使用`RedirectAttributes`的内容。 否则使用模型的内容。

如果为重定向准备了模型实例，*则将原始类型属性作为查询参数附加可能是所需的结果。然而，在注解控制器中，模型可能包含为渲染目的添加的附加属性（例如下拉字段值）。*为了避免这种属性出现在URL中的可能性，一种`@RequestMapping`方法可以声明一个类型的参数，`RedirectAttributes`并使用它来指定可供使用的确切属性`RedirectView`。如果方法重定向，则使用内容`RedirectAttributes`。否则使用模型的内容。

`RequestMappingHandlerAdapter`提供了一个名为`“ignoreDefaultModelOnRedirect”`的标志，可用于指示默认`Model`的内容，如果控制器方法重定向，则永远不要使用该模型。 相反，控制器方法应声明`RedirectAttributes`类型的属性，或者如果不这样做，则不应将任何属性传递给`RedirectView`。 MVC命名空间和MVC Java配置都将此标志设置为`false`，以保持向后兼容性。 但是，对于新应用程序，我们建议将其设置为`true`

请注意，当前请求中的URI模板变量在扩展重定向URL时自动可用，不需要通过`Model`或`RedirectAttributes`显式添加。 例如：

```java
@PostMapping("/files/{path}")
public String upload(...) {
    // ...
    return "redirect:files/{path}";
}
```

将数据传递到重定向目标的另一种方法是通过_Flash属性_。与其他重定向属性不同，Flash属性保存在HTTP会话中（因此不会出现在URL中）。有关详细信息，请参见[第18.6节“使用Flash属性”](http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-flash-attributes)。

#### 重定向：前缀

特殊的`redirect:`前缀可以让你做到这一点。 如果返回具有前缀`redirect：`的视图名称，则`UrlBasedViewResolver`（和所有子类）将认识到这是需要重定向的特殊指示。 视图名称的其余部分将被视为重定向URL。

请注意，控制器处理程序使用注释`@ResponseStatus`，注释值优先于设置的响应状态`RedirectView`。

实际效果与控制器返回`RedirectView`的效果相同，但现在控制器本身可以简单地按照逻辑视图名称操作。 逻辑视图名称，例如`redirect:/myapp/some/resource`将相对于当前Servlet上下文重定向，而诸如`redirect:http://myhost.com/some/arbitrary/path`之类的名称将重定向到绝对URL。

请注意，控制器处理程序使用`@ResponseStatus`注解，注解值优先于`RedirectView`设置的响应状态。

#### 

#### 转发：前缀

对于最终由`UrlBasedViewResolver`和子类解析的视图名称，也可以使用特殊的`forward：`前缀。 这将创建一个内部`ResourceView`（最终执行一个`RequestDispatcher.forward()`），其余的视图名称被视为一个URL。 因此，这个前缀对于`InternalResourceViewResolver`和`InternalResourceView`（例如JSP）是没有用的。 但是，当您主要使用其他视图技术时，前缀可能会很有帮助，但仍希望强制转发资源，以便由Servlet/JSP引擎处理。 （请注意，您也可以链接多个视图解析器）。

与`redirect:`前缀一样，如果带有`forward：`前缀的视图名称被注入到控制器中，则控制器不会检测到处理响应方面的任何特殊情况。

### 18.5.4ContentNegotiatingViewResolver

`ContentNegotiatingViewResolver`不会自己解析视图，而是委托给其他视图解析器，选择类似于客户端请求的视图。 有两种策略可以让客户从服务器请求表示：

- 对每个资源使用不同的URI，通常在URI中使用不同的文件扩展名。 例如，URI `http://www.example.com/users/fred.pdf`请求用户fred的PDF表示，而`http://www.example.com/users/fred.xml`请求XML表示。
- 为客户端使用相同的URI来定位资源，但是设置`Accept` HTTP请求头来列出它理解的[媒体类型](https://en.wikipedia.org/wiki/Internet_media_type)。 例如，`http://www.example.com/users/fred`的一个HTTP请求的`Accept`标头设置为`application/pdf`，请求用户fred的PDF表示，同时[`http://www.example.com/users/fred`](http://www.example.com/users/fred)使用`Accept`头设置来`text/xml`请求XML表示。 这个策略被称为[内容谈判](https://en.wikipedia.org/wiki/Content_negotiation)。

| ![](https://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/images/note.png) |
| :--------------------------------------- |
| `Accept`头的一个问题是，不可能在HTML中的Web浏览器中设置它。 例如，在Firefox中，它被固定为：`Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`因此，通常会看到使用 开发基于浏览器的Web应用程序时，每个表示的URI都是不同的。 |

为了支持资源的多重表示，Spring提供了`ContentNegotiatingViewResolver`来根据HTTP请求的文件扩展名或者`Accept`头来解析一个视图。`ContentNegotiatingViewResolver`本身并不执行视图解析，而是委托给你指定的视图解析器列表 bean属性`ViewResolvers`。

#### 1.16.6。内容谈判

您可以配置Spring MVC如何根据请求确定请求的媒体类型。

- 可用的选项是检查查询参数，
- 文件扩展名的URL路径，
- “Accept”标头，使用固定列表还是自定义策略。

默认情况下，为了向后兼容，首先检查请求URI中的路径扩展，然后检查“Accept”头。但是，如果您必须使用基于URL的内容类型解析，则强烈建议在路径扩展上使用查询参数策略，因为后者可能会导致URI变量，路径参数以及URI解码相结合的问题。

在MVC的Java配置和MVC命名寄存器`json`，`xml`，`rss`，`atom`在默认情况下，如果相应的依赖都在类路径中。额外的路径扩展到媒体类型的映射也可以被明确注册，并且为了RFD攻击检测的目的（参见[后缀模式匹配和RFD](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/web.html#mvc-ann-requestmapping-rfd)的更多细节），也具有将它们白名单作为安全扩展的效果。

以下是通过MVC Java配置自定义内容协商选项的示例：

以下是通过MVC Java配置自定义内容协商选项的示例：

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

        @Override
        public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
                configurer.mediaType("json", MediaType.APPLICATION_JSON);
        }
}
```

在MVC命名空间中，`<mvc:annotation-driven>`元素有一个 `content-negotiation-manager`属性，这个属性`ContentNegotiationManager` 可以创建一个`ContentNegotiationManagerFactoryBean`：

```xml
<!-- 必须是 id = ‘contentNegotiationManager’-->
<mvc:annotation-driven content-negotiation-manager="contentNegotiationManager"/>

<bean id="contentNegotiationManager" class="org.springframework.web.accept.ContentNegotiationManagerFactoryBean">
        <property name="mediaTypes">
                <value>
                        json=application/json
                        xml=application/xml
                </value>
        </property>
</bean>

--------2---
    <bean id="contentNegotiatingViewResolver"
        class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver">
        <property name="contentNegotiationManager">
            <bean autowire-candidate="true"
                  class="org.springframework.web.accept.ContentNegotiationManagerFactoryBean" init-method="build">
                <property name="mediaTypes">
                    <map>

                    </map>
                </property>
                <property name="defaultContentType" value="text/html"/>
                <property name="favorParameter" value="true"/>
                <property name="favorPathExtension" value="true"/>
                <property name="ignoreAcceptHeader" value="false"/>
                <property name="parameterName" value="type"/>
                <property name="useRegisteredExtensionsOnly" value="false"/>
            </bean>
        </property>
</bean>
```

### 1.6。使用Flash属性

Flash属性提供了一种请求来存储供另一个使用的属性的方法。这是重定向时最常需要的 - 例如 *Post / Redirect / Get*模式。在重定向（通常在会话中）之前，Flash属性会临时保存，以便在重定向之后立即将其删除。

Spring MVC有两个主要的抽象来支持Flash属性。`FlashMap`用于保存闪存属性，同时`FlashMapManager`用于存储，检索和管理`FlashMap`实例。

Flash属性支持始终处于“打开”状态，不需要显式启用即使未使用也不会导致创建HTTP会话。每个请求都有一个“输入”，`FlashMap`其中包含从前一个请求（如果有）传递的属性和一个`FlashMap`带有属性的“输出” ，以保存后续请求。这两个`FlashMap`实例都可以从Spring MVC中的任何地方通过静态方法访问 `RequestContextUtils`。

带注释的控制器通常不需要`FlashMap`直接使用。相反，一个 `@RequestMapping`方法可以接受一个类型的参数，`RedirectAttributes`并用它为重定向场景添加flash属性。通过添加的Flash属性 `RedirectAttributes`自动传播到“输出”FlashMap。同样，重定向之后，来自“输入”的属性`FlashMap`会自动添加到 `Model`为目标URL提供服务的控制器中。

>  # 将请求匹配到Flash属性

> Flash属性的概念存在于许多其他Web框架中，并且已经被证明有时会暴露给并发问题。这是因为根据定义，闪存属性将被存储直到下一个请求。然而，非常“下一个”请求可能不是预期的接收者，而是另一个异步请求（例如，轮询或资源请求），在这种情况下，Flash属性被过早地移除。

> 为了减少此类问题发生的可能性，请使用目标重定向URL的路径和查询参数`RedirectView`自动“戳记” `FlashMap`实例。在`FlashMapManager`查找“输入”时，默认情况下，该信息与传入请求相匹配`FlashMap`。

> 这并不能完全消除并发问题的可能性，但是尽管如此，通过重定向URL中已有的信息大大减少了这种可能性。因此，建议主要针对重定向场景使用Flash属性。

### 1.7。建立URI

Spring MVC提供了使用`UriComponentsBuilder`和构建和编码URI的机制 `UriComponents`。

例如，您可以展开和编码一个URI模板字符串：

```java
UriComponents uriComponents = UriComponentsBuilder.fromUriString(
                "http://example.com/hotels/{hotel}/bookings/{booking}").build();

URI uri = uriComponents.expand("42", "21").encode().toUri();
```

请注意，这`UriComponents`是不可变的`expand()`，`encode()`如果需要的话，和操作会返回新的实例。

您还可以使用单独的URI组件进行展开和编码：

```java
UriComponents uriComponents = UriComponentsBuilder.newInstance()
                .scheme("http").host("example.com").path("/hotels/{hotel}/bookings/{booking}").build()
                .expand("42", "21")
                .encode();
```

在Servlet环境中，`ServletUriComponentsBuilder`子类提供静态工厂方法来从Servlet请求中复制可用的URL信息：

```java
HttpServletRequest request = ...

// Re-use host, scheme, port, path and query string
// Replace the "accountId" query param

ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromRequest(request)
                .replaceQueryParam("accountId", "{id}").build()
                .expand("123")
                .encode();
```

或者，您可以选择将可用信息的一个子集复制到上下文路径（包括上下文路径）：

```
// Re-use host, port and context path
// Append "/accounts" to the path

ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromContextPath(request)
                .path("/accounts").build()
```

或者，在`DispatcherServlet`名称（例如`/main/*`）映射的情况下，还可以包含servlet映射的文字部分：

```java
// Re-use host, port, context path
// Append the literal part of the servlet mapping to the path
// Append "/accounts" to the path

ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromServletMapping(request)
                .path("/accounts").build()
```

#### 1.7.1。为控制器和方法构建URI

Spring MVC还提供了一种构建控制器方法链接的机制。例如，给出：

```
@Controller
@RequestMapping("/hotels/{hotel}")
public class BookingController {

        @GetMapping("/bookings/{booking}")
        public String getBooking(@PathVariable Long booking) {

        // ...
       }
}
```

您可以通过名称引用方法来准备链接：

```
UriComponents uriComponents = MvcUriComponentsBuilder
        .fromMethodName(BookingController.class, "getBooking", 21).buildAndExpand(42);

URI uri = uriComponents.encode().toUri();
```

在上面的例子中，我们提供了实际的方法参数值，在这种情况下是long值21，被用作路径变量并被插入到URL中。此外，我们提供了值42以填充任何剩余的URI变量，例如从类型级别请求映射继承的“酒店”变量。如果方法有更多的参数，你可以为URL提供不需要的参数。一般只有`@PathVariable`和`@RequestParam`参数是有关构造URL。

还有其他方法可以使用`MvcUriComponentsBuilder`

```
UriComponents uriComponents = MvcUriComponentsBuilder
        .fromMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);

URI uri = uriComponents.encode().toUri();
```

上面的例子使用了静态方法`MvcUriComponentsBuilder`。他们在内部依靠`ServletUriComponentsBuilder`从当前请求的方案，主机，端口，上下文路径和servlet路径准备基本URL。这在大多数情况下运作良好，但有时可能不足。例如，您可能在请求的上下文之外（例如，准备链接的批处理过程），或者您可能需要插入路径前缀（例如，从请求路径中删除并需要重新插入链接的区域设置前缀）。

对于这种情况，您可以使用静态“fromXxx”重载方法来接受 `UriComponentsBuilder`使用基本URL。或者您可以`MvcUriComponentsBuilder` 使用基本URL 创建实例，然后使用基于实例的“withXxx”方法。例如：

```
UriComponentsBuilder base = ServletUriComponentsBuilder.fromCurrentContextPath().path("/en");
MvcUriComponentsBuilder builder = MvcUriComponentsBuilder.relativeTo(base);
builder.withMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);

URI uri = uriComponents.encode().toUri();
```

#### 1.7.2。使用“转发”和“X-Forwarded- *”标题

当请求经过负载平衡器等代理时，主机，端口和方案可能会改变，这对于需要创建资源链接的应用程序提出了挑战，因为链接应反映原始请求的主机，端口和方案客户端的角度。

[RFC 7239](https://tools.ietf.org/html/rfc7239)定义了代理的“转发”HTTP头，用于提供有关原始请求的信息。还有其他非标准的标题，例如“X-Forwarded-Host”，“X-Forwarded-Port”和“X-Forwarded-Proto”。

既`ServletUriComponentsBuilder`和`MvcUriComponentsBuilder`检测，提取，并从“转发”头，或从“X -转发，主机”使用信息，“X-转发端口”和“X-转发，原”如果“转发”不存在，以便生成的链接反映原始请求。

在`ForwardedHeaderFilter`提供了一个替代方案为整个应用程序做同样的曾经和全球。过滤器包装请求以覆盖主机，端口和方案信息，并“隐藏”任何转发的头部以供后续处理。

请注意，如RFC 7239的第8部分中所述，使用转发标头时存在安全考虑事项。在应用程序级别，很难确定转发标头是否可信。这就是为什么网络上游应该被正确配置，以从外部过滤出不可信的转发标题。

没有代理并且不需要使用转发标头的应用程序可以配置`ForwardedHeaderFilter`为删除并忽略这些标头。

#### 1.7.3。从视图构建控制器和方法的URI

您还可以从视图（如JSP，Thymeleaf，FreeMarker）建立到注释控制器的链接。这可以使用 其中引用按名称映射的`fromMappingName`方法来完成`MvcUriComponentsBuilder`。

每一个都`@RequestMapping`被分配一个基于类的大写字母和完整的方法名称的默认名称。例如，`getFoo`类中的方法`FooController` 被分配名称“FC＃getFoo”。这个策略可以通过创建一个实例`HandlerMethodMappingNamingStrategy`并将其插入你 的实例来替换或定制`RequestMappingHandlerMapping`。默认策略实现也会查看name属性`@RequestMapping`并使用它，如果存在的话。这意味着如果分配的默认映射名称与另一个名称冲突（例如重载的方法），您可以明确指定一个名称`@RequestMapping`。

| **   | 分配的请求映射名称在启动时记录在TRACE级别。 |
| ---- | ------------------------ |
|      |                          |

Spring JSP标记库提供了一个叫做的函数`mvcUrl`，可以用来根据这个机制来准备控制器方法的链接。

例如给出：

```
@RequestMapping("/people/{id}/addresses")
public class PersonAddressController {

    @RequestMapping("/{country}")
    public HttpEntity getAddress(@PathVariable String country) { ... }
}
```

您可以按如下方式从JSP准备链接：

```
<%@ taglib uri="http://www.springframework.org/tags" prefix="s" %>
...
<a href="${s:mvcUrl('PAC#getAddress').arg(0,'US').buildAndExpand('123')}">Get Address</a>
```

上面的例子依赖于`mvcUrl`Spring标记库中声明的JSP函数（即META-INF / spring.tld）。对于更高级的情况（例如上一节中介绍的自定义基本URL），可以轻松定义自己的函数或使用自定义标记文件，以便使用`MvcUriComponentsBuilder`具有自定义基本URL 的特定实例。

### 1.8。使用语言环境

Spring的架构大部分支持国际化，就像Spring的web MVC框架一样。`DispatcherServlet`使您能够使用客户端的区域设置自动解析消息。这是用`LocaleResolver`对象完成的。

当请求进入时，`DispatcherServlet`查找一个语言环境解析器，如果它找到一个它尝试使用它来设置语言环境。使用该`RequestContext.getLocale()` 方法，您始终可以检索由区域设置解析程序解析的区域设置。

除了自动区域设置解析之外，您还可以在处理程序映射中附加拦截器（请参阅[使用HandlerInterceptor拦截请求以](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/web.html#mvc-handlermapping-interceptor)获取有关处理程序映射拦截器的更多信息），以便在特定情况下更改区域设置，例如，基于请求中的参数。

区域设置解析器和拦截器在`org.springframework.web.servlet.i18n`包中定义， 并以正常方式在应用程序上下文中配置。这里是Spring中包含的一个语言环境解析器的选择。

#### 1.8.1。获取时区信息

#### 1.8.1。获取时区信息

除了获取客户端的语言环境外，知道他们的时区通常也很有用。该`LocaleContextResolver`接口提供了一个扩展`LocaleResolver`，允许解析器提供更丰富`LocaleContext`，其中可能包括时区信息。

可用时，`TimeZone`可以使用该`RequestContext.getTimeZone()`方法获取 用户。时区信息将自动由日期/时间`Converter`和`Formatter`Spring's注册的对象使用 `ConversionService`。

#### 1.8.2。AcceptHeaderLocaleResolver

此语言环境解析程序检查`accept-language`客户端发送的请求中的标头（例如Web浏览器）。通常这个头字段包含客户端操作系统的区域设置。*请注意，此解析器不支持时区信息。*

#### 1.8.3。CookieLocaleResolver的

此语言环境解析程序将检查`Cookie`客户端上可能存在的是否指定了 `Locale`or `TimeZone`。如果是这样，它使用指定的细节。使用此语言环境解析器的属性，您可以指定cookie的名称以及最大年龄。在下面找到一个定义a的例子`CookieLocaleResolver`。

```
<bean id="localeResolver" class="org.springframework.web.servlet.i18n.CookieLocaleResolver">

        <property name="cookieName" value="clientlanguage"/>

        <!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) -->
        <property name="cookieMaxAge" value="100000"/>

</bean>
```

| 属性            | 默认                 | 描述                                       |
| ------------- | ------------------ | ---------------------------------------- |
| cookieName    | classname + LOCALE | Cookie的名称                                |
| 名cookieMaxAge | Servlet容器默认        | cookie保持在客户端上的最长时间。如果指定了-1，那么cookie将不会被保留; 它只有在客户端关闭浏览器之后才可用。 |
| cookiePath    | /                  | 限制Cookie的可见性到您网站的某个部分。当指定cookiePath时，cookie将只对该路径及其下面的路径可见。 |

#### 1.8.4。SessionLocaleResolver

在`SessionLocaleResolver`可以检索`Locale`并`TimeZone`从可能与用户的请求相关的会话。相比之下 `CookieLocaleResolver`，这种策略将本地选择的区域设置存储在Servlet容器中`HttpSession`。因此，这些设置对于每个会话都是临时的，因此在每个会话终止时都会丢失。

请注意，与Spring Session项目等外部会话管理机制没有直接关系。这`SessionLocaleResolver`将简单地评估和修改`HttpSession`针对当前的相应属性`HttpServletRequest`。

#### 1.8.5。LocaleChangeInterceptor

您可以通过添加`LocaleChangeInterceptor`一个处理程序映射来启用区域设置的更改（请参阅[处理](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/web.html#mvc-handlermapping)程序[映射](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/web.html#mvc-handlermapping)）。它会检测请求中的参数并更改语言环境。它调用`setLocale()`的`LocaleResolver`是也存在于上下文。以下示例显示调用`*.view`包含名为参数的所有资源`siteLanguage`现在将更改语言环境。因此，例如，对以下网址的请求`http://www.sf.net/home.view?siteLanguage=nl`会将网站语言更改为荷兰语。

```
<bean id="localeChangeInterceptor"
                class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor">
        <property name="paramName" value="siteLanguage"/>
</bean>

<bean id="localeResolver"
                class="org.springframework.web.servlet.i18n.CookieLocaleResolver"/>

<bean id="urlMapping"
                class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
        <property name="interceptors">
                <list>
                        <ref bean="localeChangeInterceptor"/>
                </list>
        </property>
        <property name="mappings">
                <value>/**/*.view=someController</value>
        </property>
</bean>
```

### 1.9。使用主题

#### 1.9.1。主题概述

您可以应用Spring Web MVC框架主题来设置应用程序的整体外观，从而提高用户体验。主题是静态资源的集合，通常是样式表和图像，它们会影响应用程序的视觉风格。

#### 1.9.2。定义主题

要在您的Web应用程序中使用主题，您必须设置`org.springframework.ui.context.ThemeSource`接口的实现 。该`WebApplicationContext` 接口扩展`ThemeSource`，但其代表职责的专用实现。默认情况下，委托将是一个`org.springframework.ui.context.support.ResourceBundleThemeSource`从类路径的根目录加载属性文件的 实现。要使用自定义`ThemeSource` 实现或配置基本名称前缀`ResourceBundleThemeSource`，可以使用保留名称在应用程序上下文中注册一个bean `themeSource`。Web应用程序上下文自动检测具有该名称的bean并使用它。

使用时`ResourceBundleThemeSource`，主题是在一个简单的属性文件中定义的。属性文件列出组成主题的资源。这里是一个例子：

```
styleSheet = / themes / cool / style.css 
background = / themes / cool / img / coolBg.jpg
```

属性的键是从视图代码引用主题元素的名称。对于JSP，通常使用与`spring:theme`标签非常相似的自定义标签来执行此操作`spring:message`。以下JSP片段使用前面示例中定义的主题来自定义外观：

```
<%@ taglib prefix="spring" uri="http://www.springframework.org/tags"%>
<html>
        <head>
                <link rel="stylesheet" href="<spring:theme code='styleSheet'/>" type="text/css"/>
        </head>
        <body style="background=<spring:theme code='background'/>">
                ...
        </body>
</html>
```

默认情况下，`ResourceBundleThemeSource`使用空的基本名称前缀。因此，属性文件是从类路径的根目录加载的。因此，您可以将 `cool.properties`主题定义放在类路径根目录中，例如in `/WEB-INF/classes`。在`ResourceBundleThemeSource`使用标准的Java资源包加载机制，允许主题的国际化。例如，我们可以使用一个`/WEB-INF/classes/cool_nl.properties`带有荷兰文字的特殊背景图片。

#### 1.9.3。主题解析器

在定义主题之后，如上一节所述，决定使用哪个主题。该 `DispatcherServlet`会寻找一个叫豆`themeResolver`，以找出`ThemeResolver`使用实施。一个主题解析器的工作方式与a相同 `LocaleResolver`。它检测用于特定请求的主题，也可以更改请求的主题。Spring提供以下主题解析器：

| 类                      | 描述                                       |
| ---------------------- | ---------------------------------------- |
| `FixedThemeResolver`   | 选择使用`defaultThemeName`属性设置的固定主题。         |
| `SessionThemeResolver` | 主题在用户的HTTP会话中维护。它只需要为每个会话设置一次，但不会在会话之间持续。 |
| `CookieThemeResolver`  | 所选主题存储在客户端的Cookie中。                      |

Spring还提供了一个`ThemeChangeInterceptor`允许使用简单的请求参数在每个请求上进行主题更改的方法。

### 1.10。Spring的多部分（文件上传）支持

#### 1.10.1。介绍

Spring的内置多部分支持可以在Web应用程序中处理文件上传。您可以使用包中`MultipartResolver`定义的可插入对象来 启用此多部分支持`org.springframework.web.multipart`。Spring提供了一个`MultipartResolver` 用于[*Commons FileUpload的实现*](https://jakarta.apache.org/commons/fileupload)，另一个用于Servlet 3.0多部分请求解析。

默认情况下，Spring没有多部分处理，因为有些开发人员想要自己处理多部分。通过将多部分解析器添加到Web应用程序的上下文中来启用Spring多部分处理。检查每个请求，看它是否包含多部分。如果找不到多部分，请求将按预期继续。如果在请求中找到多部分，`MultipartResolver`则使用在您的上下文中声明的部分。之后，请求中的多部分属性就像任何其他属性一样处理。

#### 1.10.2。与*Commons FileUpload*一起使用MultipartResolver**

以下示例显示如何使用`CommonsMultipartResolver`：

```
<bean id="multipartResolver"
                class="org.springframework.web.multipart.commons.CommonsMultipartResolver">

        <!-- one of the properties available; the maximum file size in bytes -->
        <property name="maxUploadSize" value="100000"/>

</bean>
```

当然，你也需要在你的类路径中放入适当的jar，以便多部分解析器工作。在这种情况下`CommonsMultipartResolver`，你需要使用`commons-fileupload.jar`。

当Spring `DispatcherServlet`检测到多部分请求时，它会激活已经在上下文中声明的解析器并移交请求。然后解析程序将当前包装`HttpServletRequest`成`MultipartHttpServletRequest`支持多部分文件上传的文件。使用这个`MultipartHttpServletRequest`，你可以得到关于这个请求所包含的多部分的信息，并且实际上可以在你的控制器中访问这个多部分文件。

#### 1.10.3。在*Servlet 3.0中*使用MultipartResolver

为了使用基于Servlet 3.0的多部分解析，您需要`DispatcherServlet`用一个`"multipart-config"`部分标记`web.xml`，或者`javax.servlet.MultipartConfigElement`在程序化的Servlet注册中标记 ，或者在Servlet类可能带有`javax.servlet.annotation.MultipartConfig` 注释的自定义Servlet类的情况下。配置设置（如最大大小或存储位置）需要在该Servlet注册级别应用，因为Servlet 3.0不允许从MultipartResolver完成这些设置。

一旦以上述方式之一启用了Servlet 3.0多部分解析，您可以将其添加`StandardServletMultipartResolver`到您的Spring配置中：

```xml
<bean id="multipartResolver"
                class="org.springframework.web.multipart.support.StandardServletMultipartResolver">
</bean>
```

#### 1.10.4。处理表单中的文件上传

在之后`MultipartResolver`完成了工作，请求处理像任何其他。首先，创建一个带有文件输入的表单，允许用户上传表单。编码属性（`enctype="multipart/form-data"`）让浏览器知道如何将表单编码为多部分请求：

```xml
<html>
        <head>
                <title>Upload a file please</title>
        </head>
        <body>
                <h1>Please upload a file</h1>
                <form method="post" action="/form" enctype="multipart/form-data">
                        <input type="text" name="name"/>
                        <input type="file" name="file"/>
                        <input type="submit"/>
                </form>
        </body>
</html>
```

下一步是创建一个处理文件上传的控制器。这个控制器非常类似于一个[正常的注释`@Controller`](https://docs.spring.io/spring-framework/docs/5.0.0.RC3/spring-framework-reference/web.html#mvc-ann-controller)，除了我们使用`MultipartHttpServletRequest`或者`MultipartFile`在方法参数：

```java
@Controller
public class FileUploadController {

        @PostMapping("/form")
        public String handleFormUpload(@RequestParam("name") String name,
                        @RequestParam("file") MultipartFile file) {

                if (!file.isEmpty()) {
                        byte[] bytes = file.getBytes();
                        // store the bytes somewhere
                        return "redirect:uploadSuccess";
                }

                return "redirect:uploadFailure";
        }
 
}
```

请注意，`@RequestParam`方法参数如何映射到表单中声明的输入元素。在这个例子中，没有做任何事情`byte[]`，但实际上你可以将它保存在数据库中，将它存储在文件系统中，等等。

请注意，`@RequestParam`方法参数如何映射到表单中声明的输入元素。在这个例子中，没有做任何事情`byte[]`，但实际上你可以将它保存在数据库中，将它存储在文件系统中，等等。

使用Servlet 3.0多部分解析时，您还可以使用`javax.servlet.http.Part`方法参数

**multipart-config所有的属性都是可选的，具体属性如下：**

- fileSizeThreshold: int 当数据量大于该值时，内容将被写入文件，默认值为0bytes
- location: String 存放生成的文件地址，默认值为“”，文件地址是文件系统里的据对路径，它不支持相对路径，所以一般不要配置它
- maxFileSize: long 允许上传的文件最大值。默认值为 -1，表示没有限制。
- maxRequestSize: long 针对该 multipart/form-data 请求的最大数量，默认值为 -1，表示没有限制。

`@Value("${save.directory}")`在`controller`引用`propertyPlayceHodlerConfiger`配置的属性值

#### 1.10.5。处理来自编程客户端的文件上传请求

多部分请求也可以在非RESTful服务场景中从非浏览器客户端提交。以上所有示例和配置都适用于此。但是，与通常提交文件和简单表单域的浏览器不同，编程客户机还可以发送特定内容类型的更复杂的数据，例如带有文件的多部分请求和带有JSON格式数据的第二部分：

```
POST / someUrl 
Content-Type：multipart / mixed 

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp 
Content-Disposition：form-data; name =“meta-data” 
Content-Type：application / json; charset = UTF-8 
Content-Transfer-Encoding：8bit 

{ 
	“name”：“value” 
} 
--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp 
Content-Disposition：form-data; NAME =“文件的数据”; 文件名=“file.properties” 
内容类型：文本/ XML 
内容传输编码：8位
...文件数据...
```

您可以使用`@RequestParam("meta-data") String metadata`控制器方法参数访问名为“元数据”的部分。但是，您可能更愿意接受从请求部分的主体中的JSON格式的数据初始化的强类型对象，这非常类似于`@RequestBody`借助于将非多部分请求的主体转换为目标对象的方式`HttpMessageConverter`。

您可以使用`@RequestPart`注释来代替`@RequestParam`注释来实现此目的。它允许您通过`HttpMessageConverter`考虑`'Content-Type'`多部分的头部来传递特定多部分的内容：

```
@PostMapping("/someUrl")
public String onSubmit(@RequestPart("meta-data") MetaData metadata,
                @RequestPart("file-data") MultipartFile file) {

        // ...

}
```

请注意，`MultipartFile`方法参数可以通过`@RequestParam`或可以 `@RequestPart`互换地访问。然而，`@RequestPart("meta-data") MetaData`在这种情况下，方法参数被读作JSON内容的基础上它的`'Content-Type'`头和转换的帮助`MappingJackson2HttpMessageConverter`。

### 1.11。处理异常

#### 1.11.1。HandlerExceptionResolver

Spring `HandlerExceptionResolver`实现处理控制器执行期间发生的意外异常。一个`HandlerExceptionResolver`有点象异常映射的，你可以在Web应用程序描述符定义`web.xml`。但是，它们提供了一种更灵活的方式。例如，它们提供有关在抛出异常时执行哪个处理程序的信息。此外，处理异常的编程方式为您提供了更多的选择，以便在将请求转发到另一个URL（与使用Servlet特定的异常映射时相同的最终结果）之前做出适当的响应。

除了实现`HandlerExceptionResolver`接口，这只是实现`resolveException(Exception, Handler)`方法和返回的一个问题`ModelAndView`，你也可以使用提供的`SimpleMappingExceptionResolver`或创建 `@ExceptionHandler`方法。将`SimpleMappingExceptionResolver`让您采取可能被抛出的异常的类名，并将它映射到视图名。这在功能上等同于Servlet API的异常映射功能，但是也可以从不同的处理程序实现更多细化的异常映射。`@ExceptionHandler`另一方面，注释可用于应该被调用来处理异常的方法。这些方法可以在本地内定义，`@Controller`或者可以适用`@Controller`于在`@ControllerAdvice`类中定义的许多类。以下部分更详细地解释了这一点。